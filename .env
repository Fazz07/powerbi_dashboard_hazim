VITE_YOUR_BACKEND_API_URL="http://localhost:3000"











================================================================
Directory Structure
================================================================
backend/
  config.js
  package.json
  server.js
public/
  placeholder.svg
  robots.txt
src/
  components/
    ui/
      accordion.tsx
      alert-dialog.tsx
      alert.tsx
      aspect-ratio.tsx
      avatar.tsx
      badge.tsx
      breadcrumb.tsx
      button.tsx
      calendar.tsx
      card.tsx
      carousel.tsx
      chart.tsx
      checkbox.tsx
      collapsible.tsx
      command.tsx
      context-menu.tsx
      dialog.tsx
      drawer.tsx
      dropdown-menu.tsx
      form.tsx
      hover-card.tsx
      input-otp.tsx
      input.tsx
      label.tsx
      menubar.tsx
      navigation-menu.tsx
      pagination.tsx
      popover.tsx
      progress.tsx
      radio-group.tsx
      resizable.tsx
      scroll-area.tsx
      select.tsx
      separator.tsx
      sheet.tsx
      sidebar.tsx
      skeleton.tsx
      slider.tsx
      sonner.tsx
      switch.tsx
      table.tsx
      tabs.tsx
      textarea.tsx
      toast.tsx
      toaster.tsx
      toggle-group.tsx
      toggle.tsx
      tooltip.tsx
      use-toast.ts
    Chart.tsx
    ChartScreenshot.tsx
    ChatbotPanel.tsx
    DraggableChartGrid.tsx
    EnhancedSidebar.tsx
    ModalWindow.tsx
    Navbar.tsx
    PageSidebar.tsx
    PageTabs.tsx
    PowerBIReport.tsx
    Sidebar.tsx
  data/
    mockCharts.tsx
  hooks/
    use-chart-renderer.tsx
    use-mobile.tsx
    use-theme.tsx
    use-toast.ts
    usePageManager.ts
  lib/
    utils.ts
  pages/
    Dashboard.tsx
    Index.tsx
    Login.tsx
    NotFound.tsx
    powerBiContainer.tsx
  services/
    powerBiUtils.ts
  types/
    chart.ts
    chat.ts
    page.ts
  utils/
    iframeUtils.ts
    svgUtils.ts
  App.css
  App.tsx
  index.css
  main.tsx
  vite-env.d.ts
.gitignore
components.json
eslint.config.js
index.html
package.json
postcss.config.js
README.md
tailwind.config.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts

================================================================
Files
================================================================


================
File: backend/package.json
================
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@azure/cosmos": "^4.3.0",
    "@langchain/azure-openai": "^0.0.11",
    "@langchain/core": "^0.3.42",
    "@langchain/openai": "^0.4.4",
    "axios": "^1.7.9",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "jose": "^6.0.10",
    "jsonwebtoken": "^9.0.2",
    "jwks-rsa": "^3.2.0",
    "node-cache": "^5.1.2",
    "qs": "^6.14.0"
  }
}

================
File: backend/server.js
================
// backend/server.js
const express = require("express");
const axios = require("axios");
const cors = require("cors");
const qs = require("qs");
const crypto = require("crypto");
const path = require("path");
const NodeCache = require("node-cache");
const https = require("https");
const { CosmosClient } = require("@azure/cosmos");
const jwt = require('jsonwebtoken');
const JwksRsa = require('jwks-rsa');
const config = require("./config"); // Assuming config.js is updated

const app = express();
app.use(cors());
app.use(express.json());

// State storage with TTL (10 minutes)
const stateCache = new NodeCache({ stdTTL: 600, checkperiod: 120 });

// Token cache for multiple reports
const tokenCache = new Map();

const PORT = process.env.PORT || 3000;

// REMOVED: chatHistories and questionHistories NodeCache

// Axios instance with keep-alive
const axiosInstance = axios.create({
  httpsAgent: new https.Agent({ keepAlive: true }),
});

const azureOpenAIApiUrl = `https://${config.azureOpenAIApiInstanceName}.openai.azure.com/openai/deployments/${config.azureOpenAIApiDeploymentName}/chat/completions?api-version=${config.azureOpenAIApiVersion}`;

// --- Container Variables ---
let customizationContainer;
// REMOVED: conversationContainer (was used for chat history)
let sessionHistoryContainer; // <-- NEW: For saving session data
let llmConfigurationContainer;

const llmConfigCache = new NodeCache({ stdTTL: 300, checkperiod: 60 }); // Cache LLM config for 5 minutes
const LLM_CONFIG_CACHE_KEY = 'llm_config_cache';

// --- Default LLM Configuration (fallback) ---
const DEFAULT_LLM_CONFIG = {
  systemPrompt: "You are a helpful AI assistant designed to analyze dashboard data. Provide insights based *only* on the data snapshot provided. Do not make up information.",
  temperature: 0.7,
  max_tokens: 500,
};

const jwksClient = JwksRsa({
  jwksUri: `https://login.microsoftonline.com/${config.tenantId}/discovery/v2.0/keys`,
  cache: true,
  cacheMaxEntries: 5,
  cacheMaxAge: 600000,
});

function getSigningKey(header, callback) {
  // ... (keep existing getSigningKey function)
  if (!header || !header.kid) {
    return callback(new Error('JWT header missing kid.'));
  }
  jwksClient.getSigningKey(header.kid, (err, key) => {
    if (err) {
      console.error(`[${getISTTime()}] Error fetching signing key:`, err);
      return callback(err);
    }
    const signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

const jwtOptions = {
  audience: config.clientId,
  issuer: `https://login.microsoftonline.com/${config.tenantId}/v2.0`,
  algorithms: ["RS256"],
};


// --- Initialize Cosmos DB ---
async function initializeCosmosDb() {
  try {
    const client = new CosmosClient({
      endpoint: config.cosmosDbEndpoint,
      key: config.cosmosDbKey,
    });
    const database = client.database(config.cosmosDbDatabaseId);

    await client.databases.createIfNotExists({ id: config.cosmosDbDatabaseId });

    // --- Customization Container ---
    const customizationContainerResponse = await database.containers.createIfNotExists({
      id: config.cosmosDbContainerId,
      partitionKey: { paths: ["/userId"] },
    });
    customizationContainer = customizationContainerResponse.container;
    console.log(`[${getISTTime()}] Cosmos DB Initialized: Customization Container=${config.cosmosDbContainerId}`);

    // --- Session History Container --- // <-- NEW
    const sessionContainerId = config.cosmosDbSessionContainerId; // Make sure this exists in config.js
    if (!sessionContainerId) {
        throw new Error("Missing COSMOS_SESSION_CONTAINER_ID in configuration");
    }
    const sessionContainerResponse = await database.containers.createIfNotExists({
      id: sessionContainerId,
      partitionKey: { paths: ["/userId"] }, // Partition by user ID
    });
    sessionHistoryContainer = sessionContainerResponse.container; // <-- Assign here
    console.log(`[${getISTTime()}] Cosmos DB Initialized: Session History Container=${sessionContainerId}`);

    // --- LLM Configuration Container ---
    const llmContainerResponse = await database.containers.createIfNotExists({
        id: config.cosmosDbLlmConfigContainerId,
        partitionKey: { paths: ["/configId"] },
    });
    llmConfigurationContainer = llmContainerResponse.container;
    console.log(`[${getISTTime()}] Cosmos DB Initialized: LLM Config Container=${config.cosmosDbLlmConfigContainerId}`);

    // --- Pre-fetch LLM config on startup ---
    await getLLMConfiguration(true);

  } catch (error) {
    console.error(`[${getISTTime()}] FATAL: Failed to initialize Cosmos DB:`, error);
    process.exit(1);
  }
}
// initializeCosmosDb() called later before starting server

// Authentication Middleware
const verifyAuth = (req, res, next) => {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        console.log(`[${getISTTime()}] Auth Error: Missing or malformed Authorization header`);
        return res.status(401).json({ message: 'Unauthorized: Missing or invalid token format' });
    }
    const token = authHeader.split(' ')[1];

    // --- DEV-ONLY: Dummy Token Bypass ---
    // If the token matches the hardcoded dummy token used by the frontend for simulation,
    // bypass actual JWT verification. This allows local development without a full OAuth setup.
    if (token === 'dummy-jwt-token-for-authentication-simulation' ||
        token.startsWith('dummy-jwt-token-for-')) { // Catches both email and social dummy tokens
        console.warn(`[${getISTTime()}] DEV-ONLY: Bypassing JWT verification for known dummy token: ${token.substring(0, 30)}...`);
        // Set a mock user object. This `req.user.id` will be used as the partition key
        // for Cosmos DB operations (e.g., saving dashboard customizations or chat sessions).
        req.user = {
            id: 'dev-dummy-user-id', // A consistent ID for a dummy user in dev
            name: 'Dev Dummy User',
            email: 'dev.user@example.com',
        };
        next(); // Proceed to the next middleware/route handler
        return; // Crucial: exit this middleware to prevent further execution
    }
    // --- END DEV-ONLY BYPASS ---

    jwt.verify(token, getSigningKey, jwtOptions, (err, decoded) => {
        if (err) {
        console.error(`[${getISTTime()}] Auth Error: JWT Verification failed:`, err.message);
        if (err.name === 'TokenExpiredError') return res.status(401).json({ message: 'Unauthorized: Token expired' });
        if (err.name === 'JsonWebTokenError') return res.status(401).json({ message: `Unauthorized: Invalid token (${err.message})` });
        if (err.message.includes('Unable to find a signing key')) return res.status(401).json({ message: 'Unauthorized: Cannot verify token signature (key issue)'});
        return res.status(401).json({ message: 'Unauthorized: Invalid token' });
        }

        if (!decoded || !decoded.sub) {
            console.error(`[${getISTTime()}] Auth Error: Invalid token payload - missing 'sub' claim.`);
            return res.status(401).json({ message: 'Unauthorized: Invalid token payload' });
        }

        req.user = {
            id: decoded.sub,
            name: decoded.name,
            email: decoded.preferred_username,
        };
        console.log(`[${getISTTime()}] Auth Success: User ${req.user.id} (${req.user.name || 'N/A'}) authenticated.`);
        next();
    });
};

// --- GET User Dashboard Customization ---
app.get("/api/user/dashboard", verifyAuth, async (req, res) => {
  // ... (keep existing dashboard GET endpoint)
   const userId = req.user.id;
   console.log(`[${getISTTime()}] GET /api/user/dashboard for user: ${userId}`);
   if (!customizationContainer) return res.status(503).json({ message: "Customization Database not available" });

   try {
       const { resource: customization } = await customizationContainer.item(userId, userId).read();
       if (customization) {
         res.json(customization);
       } else {
         res.status(404).json({ message: "No customization found" });
       }
   } catch (error) {
       if (error.code === 404) {
           console.log(`[${getISTTime()}] No customization found for user ${userId}`);
           return res.status(404).json({ message: "No customization found" });
       }
       console.error(`[${getISTTime()}] Error fetching dashboard config for ${userId}:`, error);
       res.status(500).json({ message: "Failed to fetch dashboard customization" });
   }
});

// --- PUT (Save/Update) User Dashboard Customization ---
app.put("/api/user/dashboard", verifyAuth, express.json(), async (req, res) => {
  // ... (keep existing dashboard PUT endpoint)
   const userId = req.user.id;
   const { visualOrder, selectedDynamicReports } = req.body;

   console.log(`[${getISTTime()}] PUT /api/user/dashboard for user: ${userId}`);
   if (!customizationContainer) return res.status(503).json({ message: "Customization Database not available" });

   if (!Array.isArray(visualOrder) || !Array.isArray(selectedDynamicReports)) {
       return res.status(400).json({ message: "Invalid data format" });
   }

   const customizationData = {
       id: userId,
       userId: userId,
       visualOrder: visualOrder,
       selectedDynamicReports: selectedDynamicReports,
       lastUpdated: new Date().toISOString(),
   };

   try {
       const { resource: savedCustomization } = await customizationContainer.items.upsert(customizationData);
       console.log(`[${getISTTime()}] Saved customization for user ${userId}`);
       res.status(200).json(savedCustomization);
   } catch (error) {
       console.error(`[${getISTTime()}] Error saving dashboard config for ${userId}:`, error);
       res.status(500).json({ message: "Failed to save dashboard customization" });
   }
});


// --- Time formatting functions ---
// ... (keep existing formatToIST, getISTTime functions)
function formatToIST(timestamp) {
    return new Date(timestamp).toLocaleString("en-IN", { timeZone: "Asia/Kolkata", hour12: false, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit" });
}
function getISTTime() {
    const date = new Date();
    const options = { timeZone: "Asia/Kolkata", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false };
    return date.toLocaleTimeString("en-IN", options);
}


// --- Token Cache Utilities ---
// ... (keep existing isTokenExpired, setToken functions)
function isTokenExpired(reportId) {
    const tokenData = tokenCache.get(reportId);
    if (!tokenData) return true;
    return Date.now() >= tokenData.expirationTime - 5 * 60 * 1000; // 5-minute buffer
}
function setToken(reportId, tokenData) {
    if (!tokenData || !tokenData.token || !tokenData.expiration) {
      console.log(`[${getISTTime()}] Token Cache - Invalid token data for report ${reportId}`);
      return;
    }
    const expirationTime = new Date(tokenData.expiration).getTime();
    tokenCache.set(reportId, {
      embedToken: tokenData.token,
      expirationTime,
    });
    const expiryIST = formatToIST(expirationTime);
    console.log(`[${getISTTime()}] Token Cache - Token cached for report ${reportId}, expires at ${expiryIST} IST`);

    const timeToRefresh = expirationTime - Date.now() - 5 * 60 * 1000;
    if (timeToRefresh > 0) {
      setTimeout(() => {
        console.log(`[${getISTTime()}] Token Refresher - Refreshing token for report ${reportId}`);
        getEmbedToken(reportId, true).catch((err) => console.error(`[${getISTTime()}] Token Refresh Error: ${err.message}`));
      }, timeToRefresh);
    }
}

// --- OAuth Endpoints ---
app.get("/auth/login", (req, res) => {
  // ... (keep existing /auth/login endpoint)
    const state = crypto.randomBytes(16).toString("hex");
    stateCache.set(state, true);
    const authUrl = `https://login.microsoftonline.com/${config.tenantId}/oauth2/v2.0/authorize?client_id=${config.clientId}&response_type=code&redirect_uri=${encodeURIComponent(config.redirectUri)}&response_mode=query&scope=openid%20profile%20email&state=${state}`;
    res.redirect(authUrl);
});

app.get("/auth/callback", async (req, res) => {
  // ... (keep existing /auth/callback endpoint)
    const { code, state } = req.query;
    if (!code || !state) return res.status(400).send("Missing code or state");
    if (stateCache.get(state) === undefined) {
        console.log(`[${getISTTime()}] GET /auth/callback - Invalid or expired state: ${state}`);
        return res.status(400).send("Invalid or expired state parameter");
    }
    stateCache.del(state);
    try {
        const tokenResponse = await axiosInstance.post(
            `https://login.microsoftonline.com/${config.tenantId}/oauth2/v2.0/token`,
            qs.stringify({ grant_type: "authorization_code", code, redirect_uri: config.redirectUri, client_id: config.clientId, client_secret: config.clientSecret }),
            { headers: { "Content-Type": "application/x-www-form-urlencoded" } }
        );
        const userToken = tokenResponse.data;
        const redirectUrl = `${config.frontendRedirectUri}?token=${userToken.id_token}`;
        res.redirect(redirectUrl);
    } catch (error) {
        console.error(`[${getISTTime()}] GET /auth/callback - Error: ${error.message}`);
        res.status(500).send("Authentication failed");
    }
});

// --- Embed Token Generation ---
async function getEmbedToken(reportId, forceRefresh = false) {
  // ... (keep existing getEmbedToken function)
    if (!forceRefresh && !isTokenExpired(reportId)) {
        const tokenData = tokenCache.get(reportId);
        console.log("tokenData.embedToken", tokenData.embedToken);
        return { token: tokenData.embedToken, expiration: new Date(tokenData.expirationTime).toISOString() };
    }
    try {
        const tokenResponse = await axiosInstance.post(
            `https://login.microsoftonline.com/${config.tenantId}/oauth2/v2.0/token`,
            qs.stringify({ grant_type: "client_credentials", client_id: config.clientId, client_secret: config.clientSecret, scope: "https://analysis.windows.net/powerbi/api/.default" }),
            { headers: { "Content-Type": "application/x-www-form-urlencoded" } }
        );
        const accessToken = tokenResponse.data.access_token;
        await axiosInstance.get(
            `https://api.powerbi.com/v1.0/myorg/groups/${config.workspaceId}`,
            { headers: { Authorization: `Bearer ${accessToken}` } }
        );
        const embedResponse = await axiosInstance.post(
            `https://api.powerbi.com/v1.0/myorg/groups/${config.workspaceId}/reports/${reportId}/GenerateToken`,
            { accessLevel: "View", allowSaveAs: false },
            { headers: { Authorization: `Bearer ${accessToken}`, "Content-Type": "application/json" } }
        );
        setToken(reportId, embedResponse.data);
        return embedResponse.data;
    } catch (error) {
        console.error(`[${getISTTime()}] getEmbedToken - Error: ${error.message}`);
        throw error;
    }
}

app.get("/getEmbedToken", async (req, res) => {
  // ... (keep existing /getEmbedToken endpoint)
    const reportId = config.reportId;
    const forceRefresh = req.query.forceRefresh === "true";
    try {
        const result = await getEmbedToken(reportId, forceRefresh);
        const embedUrl = `https://app.powerbi.com/reportEmbed?reportId=${reportId}&groupId=${config.workspaceId}`;
        const tokenData = tokenCache.get(reportId);
        const expirationIST = tokenData ? formatToIST(tokenData.expirationTime) : "N/A";
        res.json({
            token: result.token,
            embedUrl,
            expiration: `${expirationIST} IST`,
            reportId,
            cacheStatus: tokenData && !isTokenExpired(reportId) ? `Cached token valid until ${new Date(tokenData.expirationTime).toISOString()}` : "No valid token in cache",
        });
    } catch (error) {
        res.status(500).json({ error: true, errorMessage: "Failed to generate embed token", details: error.message });
    }
});

// REMOVED: getUserChatHistory function
// REMOVED: saveUserChatHistory function

// --- LLM Configuration Fetching ---
async function getLLMConfiguration(forceRefresh = false) {
    // ... (keep existing getLLMConfiguration function)
    // Check cache first (simplified here)
    const cachedConfig = llmConfigCache.get(LLM_CONFIG_CACHE_KEY);
    if (!forceRefresh && cachedConfig) {
        console.log(`[${getISTTime()}] LLM Config: Using cached config.`);
        return cachedConfig;
    }

    if (!llmConfigurationContainer) {
        console.warn(`[${getISTTime()}] LLM Config: Container not available, using default.`);
        return DEFAULT_LLM_CONFIG;
    }

    try {
        const docId = config.llmConfigDocId;
        const partitionKey = config.llmConfigPartitionKey;
        console.log(`[${getISTTime()}] LLM Config: Fetching from DB (ID=${docId}, PK=${partitionKey})`);
        const { resource } = await llmConfigurationContainer.item(docId, partitionKey).read();

        if (resource) {
            const configData = {
                systemPrompt: resource.systemPrompt || DEFAULT_LLM_CONFIG.systemPrompt,
                temperature: resource.temperature ?? DEFAULT_LLM_CONFIG.temperature, // Use ?? for 0 value
                max_tokens: resource.max_tokens || DEFAULT_LLM_CONFIG.max_tokens,
            };
            console.log(`[${getISTTime()}] LLM Config: Found in DB:`, configData);
            llmConfigCache.set(LLM_CONFIG_CACHE_KEY, configData); // Update cache
            return configData;
        } else {
            console.warn(`[${getISTTime()}] LLM Config: Config document not found in DB, using default.`);
            llmConfigCache.set(LLM_CONFIG_CACHE_KEY, DEFAULT_LLM_CONFIG); // Cache default
            return DEFAULT_LLM_CONFIG;
        }
    } catch (err) {
        if (err.code === 404) {
            console.warn(`[${getISTTime()}] LLM Config: Config document not found (404), using default.`);
        } else {
            console.error(`[${getISTTime()}] LLM Config: Error reading config from DB:`, err);
        }
        llmConfigCache.set(LLM_CONFIG_CACHE_KEY, DEFAULT_LLM_CONFIG); // Cache default on error
        return DEFAULT_LLM_CONFIG;
    }
}

// // --- LLM Response Endpoint (Stream, No History Persistence) ---
// app.post('/llm-', verifyAuth, async (req, res) => {
//   const userId = req.user.id;
//   console.log("req.body: ", req.body);
//   // Receive messages *from the current session* provided by the client
//   const { data, messages: currentSessionMessages, userInput } = req.body;

//   console.log(`[${getISTTime()}] POST /llm-response User: ${userId}, Input: "${userInput}"`);

//   if (!userInput || !Array.isArray(currentSessionMessages)) {
//       return res.status(400).json({ error: "Missing userInput or invalid messages format" });
//   }

//   // Database check removed for chat history, llm config check remains implicitly in getLLMConfiguration

//   try {
//       const llmConfig = await getLLMConfiguration();

//       // Prepare messages for LLM (System Prompt + Current Session Messages + New User Input)
//       // Note: currentSessionMessages comes from the client's state for *this session*
//       const messagesForLLM = [
//           {
//               role: "system",
//               content: `${llmConfig.systemPrompt}\nUse the following data snapshot:\n${data}`
//           },
//           ...currentSessionMessages, // Add history *from the current session*
//           { role: "user", content: userInput } // Add current user input
//       ];

//       console.log(`[${getISTTime()}] LLM Request User: ${userId} - Temp: ${llmConfig.temperature}, MaxTokens: ${llmConfig.max_tokens}. Messages sent: ${messagesForLLM.length}`);

//       const llmResponse = await axiosInstance.post(azureOpenAIApiUrl, {
//           messages: messagesForLLM, // Send the prepared messages
//           stream: true,
//           temperature: llmConfig.temperature,
//           max_tokens: llmConfig.max_tokens
//       }, {
//           headers: {
//               'api-key': config.azureOpenAIApiKey,
//               'Content-Type': 'application/json'
//           },
//           responseType: 'stream'
//       });
//       const responseStream = llmResponse.data;

//       res.setHeader('Content-Type', 'text/event-stream');
//       res.setHeader('Cache-Control', 'no-cache');
//       res.setHeader('Connection', 'keep-alive');
//       res.flushHeaders();

//       // Pipe stream to client - *NO SERVER-SIDE HISTORY SAVING HERE*
//       responseStream.on('data', (chunk) => {
//           res.write(chunk); // Forward chunk directly
//       });

//       responseStream.on('end', () => {
//           console.log(`[${getISTTime()}] LLM Stream End User: ${userId}.`);
//           res.end(); // End the SSE stream to the client
//       });

//       responseStream.on('error', (streamError) => {
//           console.error(`[${getISTTime()}] LLM Stream Error User ${userId}:`, streamError);
//           if (!res.headersSent) {
//               res.status(500).json({ error: 'LLM stream failed' });
//           } else {
//               res.write('event: error\ndata: {"message": "Stream error occurred"}\n\n');
//               res.end();
//           }
//       });

//   } catch (error) {
//       console.error(`[${getISTTime()}] LLM Endpoint Error User ${userId}:`, error.response?.data || error.message);
//       if (!res.headersSent) {
//          res.status(error.response?.status || 500).json({ error: 'LLM processing failed', details: error.response?.data?.error?.message || error.message });
//       } else {
//          res.write(`event: error\ndata: {"message": "Internal server error: ${error.message}"}\n\n`);
//          res.end();
//       }
//   }
// });
app.post('/llm-response', verifyAuth, async (req, res) => {
    const userId = req.user.id;
    console.log("req.body: ", req.body);
  const { data, messages: currentSessionMessages, userInput } = req.body;

  console.log(`[${getISTTime()}] POST /llm-response User: ${userId}, Input: "${userInput}"`);

  if (!userInput || !Array.isArray(currentSessionMessages)) {
    return res.status(400).json({ error: 'Missing userInput or invalid messages format' });
  }

  try {
    // Immediately mock the AI response without calling external API
    console.log(`[${getISTTime()}] Mocking LLM response for User: ${userId}`);

    // Set up Server-Sent Events headers
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.flushHeaders();

    // Send a single SSE message with the mock content
    const mockContent = 'Hey, i\'am working!';
    res.write(`data: ${JSON.stringify({ content: mockContent })}\n\n`);

    // End the SSE stream
    console.log(`[${getISTTime()}] Mock LLM Stream End for User: ${userId}`);
    res.end(); // Simulate delay between chunks

    } catch (error) {
        console.error(`[${getISTTime()}] LLM Endpoint Error User ${userId}:`, error.message);
        if (!res.headersSent) {
            res.status(500).json({ error: 'Mocked LLM processing failed', details: error.message });
        } else {
            res.write(`event: error\ndata: {"message": "Internal server error: ${error.message}"}\n\n`);
            res.end();
        }
    }
});


// --- NEW: Save Chat Session Endpoint ---
app.post("/api/session/save", verifyAuth, async (req, res) => {
    const userId = req.user.id;
    const { sessionId, messages, reason } = req.body; // reason: 'timeout' or 'manual_close'

    console.log(`[${getISTTime()}] POST /api/session/save User: ${userId}, Session: ${sessionId}, Reason: ${reason}, Messages: ${messages?.length ?? 0}`);

    if (!sessionHistoryContainer) {
        return res.status(503).json({ message: "Session Database not available" });
    }
    if (!sessionId || !Array.isArray(messages) || messages.length === 0 || !reason) {
        return res.status(400).json({ message: "Invalid data: Missing sessionId, messages, zero messages, or reason" });
    }

    const sessionData = {
        id: sessionId,          // Document ID is the session ID
        sessionId: sessionId,   // Field for easier querying if needed
        userId: userId,         // Partition key
        messages: messages,     // The array of messages from the session
        saveReason: reason,     // 'timeout' or 'manual_close'
        sessionEndedAt: new Date().toISOString(),
        // You could add sessionStartedAt if passed from frontend
    };

    try {
        await sessionHistoryContainer.items.create(sessionData); // Use create for unique sessions
        console.log(`[${getISTTime()}] Session Saved: User ${userId}, Session ${sessionId}`);
        res.status(201).json({ message: "Session saved successfully" });
    } catch (error) {
        console.error(`[${getISTTime()}] Error saving session User ${userId}, Session ${sessionId}:`, error);
        // Handle potential conflict if session ID somehow reused (though UUID should prevent this)
        if (error.code === 409) {
             return res.status(409).json({ message: "Conflict: Session ID already exists" });
        }
        res.status(500).json({ message: "Failed to save session data" });
    }
});


// --- Static Files and Catch-all ---
app.use(express.static(path.join(__dirname, "../dist")));
app.get("*", (req, res) => {
  res.sendFile(path.join(__dirname, "../dist", "index.html"), (err) => {
    if (err) res.status(500).send(err);
  });
});

// Initialize DB and Start Server
initializeCosmosDb().then(() => {
    app.listen(PORT, () => {
        console.log(`[${getISTTime()}] Server running on port ${PORT}`);
    });
}).catch(err => {
    console.error(`[${getISTTime()}] Server failed to start due to DB initialization error: ${err}`);
    process.exit(1);
});






================
File: src/components/Chart.tsx
================
// src/components/Chart.tsx
import React, { useState, useRef, useEffect } from 'react';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { ChartType } from '@/types/chart';
import { X, Loader2 } from 'lucide-react';
import { svgToDataUrl } from '@/utils/svgUtils';
import { captureIframeAsImage } from '@/utils/iframeUtils'; // Note: This utility creates a placeholder, not a real screenshot.
import { useToast } from '@/hooks/use-toast';
import * as pbi from 'powerbi-client';
import { powerBiService, PowerBiEmbedData } from '@/services/powerBiUtils';
import { parseData } from '@/utils/dataParsing'; // <--- NEW: Import parseData

interface ChartProps {
  chart: ChartType;
  isEditMode: boolean;
  onRemove: (id: string) => void;
  // onAskQuestion now accepts chartId, chartDataForLLM, and chartContentForDisplay
  onAskQuestion: (question: string, chartId: string, chartDataForLLM?: string, chartContentForDisplay?: string) => void; // <--- MODIFIED
  mainEmbedData: PowerBiEmbedData | null;
  // Prop to receive filters from other charts
  currentFilters: pbi.models.IFilter[];
  // Callback to report data selections from this visual
  onVisualDataSelected: (chartId: string, filters: pbi.models.IFilter[]) => void;
}

const Chart = ({
  chart,
  isEditMode,
  onRemove,
  onAskQuestion,
  mainEmbedData,
  currentFilters,
  onVisualDataSelected,
}: ChartProps) => {
  const { toast } = useToast();
  const [isLoading, setIsLoading] = useState(false);
  const [pbiLoading, setPbiLoading] = useState(true);
  const [screenshotUrl, setScreenshotUrl] = useState<string | null>(null);
  const chartRef = useRef<HTMLDivElement>(null);
  const pbiContainerRef = useRef<HTMLDivElement>(null);
  const isMounted = useRef(true);
  const [pbiVisual, setPbiVisual] = useState<pbi.Visual | null>(null);

  useEffect(() => {
    return () => {
      isMounted.current = false;
      if (pbiContainerRef.current) {
        console.log(`[Chart-${chart.id}] Cleaning up PBI embed instance on unmount.`);
        powerBiService.reset(pbiContainerRef.current);
      }
    };
  }, [chart.id]);

  console.log(`[Chart-${chart.id}] Render. Type: ${chart.type}, Name: ${chart.name}, pbiLoading: ${pbiLoading}, PBI Config:`, chart.powerBiConfig);

  useEffect(() => {
    if (chart.type !== 'powerbi' || !chart.powerBiConfig || !mainEmbedData || !pbiContainerRef.current) {
      console.log(`[Chart-${chart.id}] PBI embed conditions not met. Type: ${chart.type}, Has Config: ${!!chart.powerBiConfig}, Has Main Embed Data: ${!!mainEmbedData}, Has Container Ref: ${!!pbiContainerRef.current}`);
      if (isMounted.current && chart.type === 'powerbi' && pbiLoading) {
        setPbiLoading(false);
      }
      return;
    }

    const container = pbiContainerRef.current;
    const { pageName, visualName } = chart.powerBiConfig;
    const { token, embedUrl, reportId } = mainEmbedData;

    console.log(`[Chart-${chart.id}] Attempting to embed PBI visual. ReportId: ${reportId}, Page: ${pageName}, Visual: ${visualName}, EmbedUrl: ${embedUrl}`);

    if (isMounted.current) {
      setPbiLoading(true);
    }

    powerBiService.reset(container);

    const config: pbi.IVisualEmbedConfiguration = {
      type: 'visual',
      accessToken: token,
      embedUrl: embedUrl,
      id: reportId,
      pageName: pageName,
      visualName: visualName,
      permissions: pbi.models.Permissions.Read,
      tokenType: pbi.models.TokenType.Embed,
      settings: {
        filterPaneEnabled: false,
        navContentPaneEnabled: false,
      }
    };

    let visual: pbi.Visual | undefined;

    try {
      visual = powerBiService.embed(container, config) as pbi.Visual;
      setPbiVisual(visual);

      visual.off("loaded");
      visual.off("error");
      visual.off("rendered");
      visual.off("dataSelected");

      visual.on("loaded", () => {
        console.log(`[Chart-${chart.id}] Power BI visual loaded.`);
      });

      visual.on("rendered", () => {
        console.log(`[Chart-${chart.id}] Power BI visual rendered.`);
        if (isMounted.current) {
          setPbiLoading(false);
        }
      });

      visual.on("error", (event) => {
        console.error(`[Chart-${chart.id}] Power BI visual error:`, event.detail);
        if (isMounted.current) {
          setPbiLoading(false);
          const errorMessage = (event.detail as any)?.message || 'Unknown error occurred during Power BI embedding.';
          toast({ title: "Power BI Error", description: `Failed to load ${chart.name}: ${errorMessage}`, variant: "destructive", duration: 5000 });
        }
      });

      visual.on("dataSelected", (event) => {
        const dataSelectedEvent = event.detail as any;
        console.log(`[Chart-${chart.id}] Data selected event:`, dataSelectedEvent);
        const filters: pbi.models.IFilter[] = [];
        if (dataSelectedEvent.dataPoints && dataSelectedEvent.dataPoints.length > 0) {
          dataSelectedEvent.dataPoints.forEach((dp: any) => {
            if (dp.identity && dp.identity.length > 0) {
              dp.identity.forEach((id: any) => {
                if (id.target && typeof id.target === 'object' && 'table' in id.target && 'column' in id.target && id.equals !== undefined) {
                  filters.push({
                    $schema: "http://powerbi.com/product/schema#basic",
                    target: {
                      table: id.target.table,
                      column: id.target.column
                    },
                    operator: "In",
                    values: [id.equals]
                  } as pbi.models.IBasicFilter);
                }
              });
            }
          });
          onVisualDataSelected(chart.id, filters);
        } else {
          console.log(`[Chart-${chart.id}] Selection cleared or no data points.`);
          onVisualDataSelected(chart.id, []);
        }
      });
    } catch (error) {
      console.error(`[Chart-${chart.id}] Failed to call powerBiService.embed:`, error);
      if (isMounted.current) {
        setPbiLoading(false);
        toast({ title: "Power BI Embedding Failed", description: `Could not start embedding for ${chart.name}. Check console.`, variant: "destructive", duration: 5000 });
      }
    }

    return () => {
      setPbiVisual(null);
      if (container) {
        console.log(`[Chart-${chart.id}] Cleaning up PBI embed instance on dependency change/unmount.`);
        powerBiService.reset(container);
      }
    };
  }, [
    chart.id,
    chart.type,
    chart.powerBiConfig?.pageName,
    chart.powerBiConfig?.visualName,
    mainEmbedData?.token,
    mainEmbedData?.embedUrl,
    mainEmbedData?.reportId,
    toast,
    onVisualDataSelected
  ]);

  useEffect(() => {
    if (pbiVisual && chart.type === 'powerbi') {
      if (currentFilters && currentFilters.length > 0) {
        console.log(`[Chart-${chart.id}] Applying filters:`, currentFilters);
        pbiVisual.setFilters(currentFilters)
          .catch(error => console.error(`[Chart-${chart.id}] Failed to apply filters:`, error));
      } else {
        console.log(`[Chart-${chart.id}] Clearing filters.`);
        pbiVisual.setFilters([])
          .catch(error => console.error(`[Chart-${chart.id}] Failed to clear filters:`, error));
      }
    }
  }, [pbiVisual, currentFilters, chart.type]);

  useEffect(() => {
    console.log(`[Chart-${chart.id}] Screenshot logic. Type: ${chart.type}, Content: ${chart.content ? chart.content.substring(0, 30) + '...' : 'N/A'}`);
    if (chart.type === 'iframe' || chart.type === 'powerbi') {
      setScreenshotUrl(null);
      return;
    }

    const captureChartImage = async () => {
      if (chart.content) {
        try {
          const tempContainer = document.createElement('div');
          tempContainer.style.position = 'absolute';
          tempContainer.style.left = '-9999px';
          tempContainer.style.width = '500px';
          tempContainer.style.height = '300px';
          tempContainer.innerHTML = chart.content;
          document.body.appendChild(tempContainer);
          await new Promise(resolve => setTimeout(resolve, 100));

          const svgElement = tempContainer.querySelector('svg');

          if (svgElement) {
            const dataUrl = await svgToDataUrl(svgElement);
            if (isMounted.current) {
              setScreenshotUrl(dataUrl);
            }
          } else {
            console.warn(`[Chart-${chart.id}] No SVG element found in content for screenshot.`);
            if (isMounted.current) {
              setScreenshotUrl(null);
            }
          }

          document.body.removeChild(tempContainer);
        } catch (error) {
          console.error(`[Chart-${chart.id}] Failed to capture chart image:`, error);
          if (isMounted.current) {
            setScreenshotUrl(null);
          }
        }
      } else {
        if (isMounted.current) {
          setScreenshotUrl(null);
        }
      }
    };

    const timer = setTimeout(captureChartImage, 300);
    return () => clearTimeout(timer);
  }, [chart.content, chart.type]);

  const handleAskQuestion = async (question: string) => {
    setIsLoading(true);
    console.log(`[Chart-${chart.id}] handleAskQuestion for display content: ${question}`);

    try {
      let contentForDisplay: string | undefined; // Content to display in chat history
      let dataForLLM: string | undefined;       // <--- NEW: Data to send to LLM

      if (chart.type === 'powerbi') {
        // For Power BI visuals, we cannot directly export data from individual visual embeds
        // Instead, provide the LLM with metadata and context about the visual.
        if (pbiVisual) {
          try {
            // Construct a descriptive message for the LLM
            dataForLLM = `The user is asking about the Power BI visual titled "${chart.name}". ` +
                         `This visual is located on the Power BI report page "${chart.powerBiConfig?.pageName || 'N/A'}" ` +
                         `and specifically represents the visual named "${chart.powerBiConfig?.visualName || 'N/A'}". ` +
                         `Due to technical limitations of direct visual embedding, raw numerical data from this specific visual ` +
                         `cannot be automatically extracted for analysis. Please provide insights based on the visual's title, ` +
                         `its description ("${chart.content}"), and the overall context of the user's question.`;

            // Content for display in chat history will be a textual representation
            contentForDisplay = `Power BI Visual: ${chart.name} (Page: ${chart.powerBiConfig?.pageName || 'N/A'}, Visual: ${chart.powerBiConfig?.visualName || 'N/A'}). No direct data extractable. AI will use metadata.`;

            console.log(`[Chart-${chart.id}] PBI visual data for LLM (metadata):`, dataForLLM);
            toast({ title: "Note for AI", description: `Direct data extraction from ${chart.name} not possible. AI will use metadata.` });
          } catch (error) {
            console.error(`[Chart-${chart.id}] Error preparing PBI visual data for LLM:`, error);
            dataForLLM = `Failed to prepare context for Power BI visual: ${chart.name}. Error: ${error.message || 'unknown'}`;
            contentForDisplay = `Power BI Visual: ${chart.name}. (Error preparing context)`;
            toast({ title: "Warning", description: `Failed to prepare context for ${chart.name}.`, variant: "destructive" });
          }
        } else {
          console.warn(`[Chart-${chart.id}] pbiVisual instance not available for data export or context preparation.`);
          dataForLLM = `Power BI visual for ${chart.name} is not fully loaded or available. Cannot extract data or metadata.`;
          contentForDisplay = `Power BI Visual: ${chart.name} (Not ready).`;
          toast({ title: "Warning", description: `Power BI visual ${chart.name} not ready for AI interaction.`, variant: "destructive" });
        }
      } else if (chart.type === 'iframe') {
        // For full iframe Power BI reports, try to capture a placeholder image
        try {
          toast({ title: "Capturing chart", description: "Taking a snapshot of the Power BI report..." });
          const imageDataUrl = await captureIframeAsImage(chart.content);
          contentForDisplay = imageDataUrl;
          dataForLLM = `The user is referencing a full Power BI report embedded via iframe. The URL is: ${chart.content}. A visual placeholder is provided for context.`; // <--- NEW: Textual data for LLM
          console.log(`[Chart-${chart.id}] Iframe content for display (placeholder image data or URL):`, contentForDisplay ? contentForDisplay.substring(0, 50) + '...' : 'N/A');
        } catch (error) {
          console.error(`[Chart-${chart.id}] Failed to capture iframe as image for display:`, error);
          toast({ title: "Capture failed", description: "Using URL reference instead", variant: "destructive" });
          contentForDisplay = chart.content; // Fallback to URL string for display
          dataForLLM = `The user is referencing a full Power BI report embedded via iframe. The URL is: ${chart.content}. (Failed to capture image).`; // <--- NEW: Textual data for LLM
        }
      } else { // This is for SVG based charts
        if (chart.content) {
          try {
            toast({ title: "Capturing chart", description: "Converting chart SVG to image for AI..." });
            // Convert the raw SVG string content to a PNG data URL for display
            const imageDataUrl = await svgToDataUrl(chart.content);
            contentForDisplay = imageDataUrl;
            dataForLLM = chart.content; // <--- NEW: Send raw SVG content to LLM
            console.log(`[Chart-${chart.id}] SVG content for display (image data):`, contentForDisplay ? contentForDisplay.substring(0, 50) + '...' : 'N/A');
          } catch (error) {
            console.error(`[Chart-${chart.id}] Failed to convert SVG to image for display:`, error);
            toast({ title: "Capture failed", description: "Using raw SVG content instead", variant: "destructive" });
            contentForDisplay = chart.content; // Fallback to raw SVG content if conversion fails
            dataForLLM = chart.content; // <--- NEW: Still send raw SVG to LLM
          }
        } else {
          contentForDisplay = "No chart content available.";
          dataForLLM = "No chart content available."; // <--- NEW
        }
      }

      // Pass the chart ID, the data for LLM, and the content for display to the parent component
      onAskQuestion(question, chart.id, dataForLLM, contentForDisplay); // <--- MODIFIED
    } catch (error) {
      console.error(`[Chart-${chart.id}] Failed to process chart content for display/data (outer catch):`, error);
      onAskQuestion(question, chart.id, "Error processing chart data.", chart.content); // <--- MODIFIED: Fallback to raw content/error message
    } finally {
      setIsLoading(false);
    }
  };

  const handleDeleteClick = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    console.log(`[Chart-${chart.id}] handleDeleteClick`);
    onRemove(chart.id);
  };

  let actualChartContent: React.ReactNode;

  if (chart.type === 'powerbi') {
    actualChartContent = (
      <>
        {pbiLoading && (
          <div className="absolute inset-0 flex flex-col items-center justify-center bg-background/80 z-10">
            <Loader2 className="h-8 w-8 animate-spin mb-2 text-primary" />
            <span className="text-muted-foreground">Loading Power BI Visual...</span>
          </div>
        )}
        <div
          ref={pbiContainerRef}
          style={{ width: '100%', height: '100%', opacity: pbiLoading ? 0 : 1, transition: 'opacity 0.3s ease-in-out' }}
        />
      </>
    );
  } else if (chart.type === 'iframe') {
    actualChartContent = (
      <iframe
        src={chart.content}
        title={chart.name}
        className="w-full h-full border-none"
        allowFullScreen
      />
    );
  } else { // SVG based charts
    actualChartContent = (
      <div className="w-full h-full flex items-center justify-center p-4">
        {screenshotUrl ? (
          <img
            src={screenshotUrl}
            alt={chart.name}
            className="w-full h-full object-contain"
          />
        ) : (
          <p className="text-muted-foreground">Loading chart image...</p>
        )}
      </div>
    );
  }

  return (
    <Card ref={chartRef} className="overflow-hidden relative flex flex-col h-full">
      {isEditMode && chart.type !== 'powerbi' && (
        <Button
          variant="destructive"
          size="icon"
          className="absolute top-2 right-2 z-10 chart-delete-button"
          onClick={handleDeleteClick}
          onMouseDown={(e) => e.stopPropagation()}
          onTouchStart={(e) => e.stopPropagation()}
          aria-label="Remove chart"
        >
          <X className="h-4 w-4" />
        </Button>
      )}
      <div className="p-4 border-b">
        <h3 className="text-lg font-medium">{chart.name}</h3>
      </div>
      <div
        className="flex-1 min-h-[300px] bg-background relative flex items-center justify-center"
        id={`chart-content-wrapper-${chart.id}`}
      >
        {actualChartContent}
      </div>
      <div className="p-4 bg-muted/10 border-t">
        <h4 className="text-sm font-medium mb-2">Ask AI about this chart:</h4>
        <div className="grid grid-cols-1 gap-2">
          {(chart.askableQuestions || []).map((question, idx) => (
            <Button
              key={idx}
              variant="secondary"
              size="sm"
              className="text-left justify-start text-xs"
              onClick={() => handleAskQuestion(question)}
              disabled={isLoading}
            >
              {question}
              {isLoading && <span className="ml-2 animate-pulse">...</span>} {/* <--- MODIFIED: removed idx === 0 */}
            </Button>
          ))}
        </div>
      </div>
    </Card>
  );
};

export default Chart;



================
File: src/utils/svgUtils.ts
================


/**
 * Captures an iframe's content as an image
 * @param iframeUrl The URL of the iframe to capture
 * @returns Promise that resolves to a data URL of the image
 */
export const captureIframeAsImage = (iframeUrl: string): Promise<string> => {
  return new Promise((resolve, reject) => {
    try {
      // Create a temporary iframe to load the content
      const tempIframe = document.createElement('iframe');
      tempIframe.style.position = 'absolute';
      tempIframe.style.left = '-9999px';
      tempIframe.style.width = '800px';
      tempIframe.style.height = '600px';
      tempIframe.src = iframeUrl;
      
      document.body.appendChild(tempIframe);
      
      // Wait for iframe to load
      tempIframe.onload = async () => {
        try {
          // Give it a moment for content to render
          await new Promise(resolve => setTimeout(resolve, 1500));
          
          // Create a canvas element to draw the iframe content
          const canvas = document.createElement('canvas');
          canvas.width = 800;
          canvas.height = 600;
          
          const ctx = canvas.getContext('2d');
          if (!ctx) {
            reject(new Error('Could not get canvas context'));
            document.body.removeChild(tempIframe);
            return;
          }
          
          // Draw a placeholder background
          ctx.fillStyle = '#f9fafb'; // bg-background color
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Add Power BI logo or icon (small representation)
          ctx.fillStyle = '#F2C811'; // Power BI yellow
          ctx.fillRect(canvas.width / 2 - 40, canvas.height / 2 - 70, 80, 60);
          
          // Add text indicating this is a Power BI report
          ctx.fillStyle = '#000000';
          ctx.font = 'bold 20px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('Power BI Report', canvas.width / 2, canvas.height / 2 + 20);
          
          // Add the URL as reference (shortened)
          ctx.font = '14px sans-serif';
          const displayUrl = iframeUrl.length > 50 ? iframeUrl.substring(0, 47) + '...' : iframeUrl;
          ctx.fillText(displayUrl, canvas.width / 2, canvas.height / 2 + 50);
          
          // Convert to data URL
          const dataUrl = canvas.toDataURL('image/png');
          
          // Clean up
          document.body.removeChild(tempIframe);
          
          resolve(dataUrl);
        } catch (error) {
          document.body.removeChild(tempIframe);
          reject(error);
        }
      };
      
      // Handle iframe load errors
      tempIframe.onerror = () => {
        document.body.removeChild(tempIframe);
        reject(new Error('Failed to load iframe content'));
      };
    } catch (error) {
      reject(error);
    }
  });
};



================
File: src/utils/svgUtils.ts
================
/**
 * Convert an SVG element or SVG string to a data URL
 * @param svgElement - The SVG element or SVG string to convert
 * @returns A Promise that resolves to a data URL of the image
 */
export const svgToDataUrl = (svgElement: SVGElement | string): Promise<string> => {
  return new Promise((resolve, reject) => {
    try {
      let svgString: string;
      
      if (typeof svgElement === 'string') {
        svgString = svgElement;
      } else {
        svgString = new XMLSerializer().serializeToString(svgElement);
      }
      
      // Add XML declaration if not present
      if (!svgString.startsWith('<?xml')) {
        svgString = '<?xml version="1.0" standalone="no"?>' + svgString;
      }
      
      // Create a Blob from the SVG string
      const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
      
      // Create a data URL from the Blob
      const url = URL.createObjectURL(blob);
      
      // Create an Image element to properly render the SVG
      const img = new Image();
      img.onload = () => {
        // Create a canvas to draw the image
        const canvas = document.createElement('canvas');
        canvas.width = img.width || 600;  // Default width if not specified
        canvas.height = img.height || 400; // Default height if not specified
        
        // Draw the image on the canvas
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          reject(new Error('Failed to get canvas context'));
          return;
        }
        
        ctx.drawImage(img, 0, 0);
        
        // Convert canvas to data URL
        const dataUrl = canvas.toDataURL('image/png');
        
        // Clean up
        URL.revokeObjectURL(url);
        
        resolve(dataUrl);
      };
      
      img.onerror = () => {
        URL.revokeObjectURL(url);
        reject(new Error('Failed to load SVG image'));
      };
      
      img.src = url;
    } catch (error) {
      reject(error);
    }
  });
};



================
File: src/components/ChartScreenshot.tsx
================
import { useState, useEffect, useRef } from 'react';
import { svgToDataUrl } from '@/utils/svgUtils';

interface ChartScreenshotProps {
  htmlContent: string;
  width?: number;
  height?: number;
}

const ChartScreenshot = ({ htmlContent, width, height }: ChartScreenshotProps) => {
  const [imageUrl, setImageUrl] = useState<string | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!htmlContent) return;

    const captureChart = async () => {
      try {
        // Create a temporary container to render the HTML
        const tempContainer = document.createElement('div');
        tempContainer.style.position = 'absolute';
        tempContainer.style.left = '-9999px';
        // Use the provided dimensions or default values
        tempContainer.style.width = width ? `${width}px` : '500px';
        tempContainer.style.height = height ? `${height}px` : '300px';
        tempContainer.innerHTML = htmlContent;
        document.body.appendChild(tempContainer);

        // Wait a moment for any scripts in the HTML to execute
        await new Promise(resolve => setTimeout(resolve, 100));

        // Find SVG elements in the container
        const svgElement = tempContainer.querySelector('svg');
        
        if (svgElement) {
          // Set the SVG dimensions to match container if needed
          if (width) svgElement.setAttribute('width', width.toString());
          if (height) svgElement.setAttribute('height', height.toString());
          
          // Convert SVG to data URL
          const dataUrl = await svgToDataUrl(svgElement);
          setImageUrl(dataUrl);
        } else {
          console.warn('No SVG element found in chart content');
          setImageUrl(null);
        }

        // Remove the temporary container
        document.body.removeChild(tempContainer);
      } catch (error) {
        console.error('Error capturing chart:', error);
        // Set a fallback image or message
        setImageUrl(null);
      }
    };

    captureChart();
  }, [htmlContent, width, height]);

  if (!imageUrl) {
    return (
      <div ref={containerRef} className="w-full h-full flex items-center justify-center bg-muted/20">
        <p className="text-sm text-muted-foreground">Loading chart image...</p>
      </div>
    );
  }

  return (
    <div ref={containerRef} className="w-full h-full">
      <img 
        src={imageUrl} 
        alt="Chart visualization" 
        className="w-full h-full object-contain"
        style={{ maxWidth: '100%', maxHeight: '100%' }}
      />
    </div>
  );
};

export default ChartScreenshot;

================
File: src/components/ChatbotPanel.tsx
================
// src/components/ChatbotPanel.tsx
import React, { useState, useRef, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Send, ChevronRight, ChevronLeft, X, Mic, MicOff, Loader2 } from 'lucide-react';
import { ChatMessage, ChatSuggestion, SpeechRecognition } from '@/types/chat';
import { ScrollArea } from '@/components/ui/scroll-area';
import { useToast } from '@/hooks/use-toast';
import ChartScreenshot from './ChartScreenshot';

interface ChatbotPanelProps {
  isOpen: boolean;
  onToggle: () => void;
  chatHistory: ChatMessage[];
  onSendMessage: (message: string) => void;
  suggestions: ChatSuggestion[];
  selectedChart?: string;
}

const ChatbotPanel = ({
  isOpen,
  onToggle,
  chatHistory,
  onSendMessage,
  suggestions,
  selectedChart
}: ChatbotPanelProps) => {
  const { toast } = useToast();
  const [message, setMessage] = useState('');
  const [width, setWidth] = useState(450);
  const [isResizing, setIsResizing] = useState(false);
  const [isListening, setIsListening] = useState(false);
  const chatContainerRef = useRef<HTMLDivElement>(null);
  const startXRef = useRef(0);
  const startWidthRef = useRef(0);
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  // Helper to determine if content is an image data URL
  const isImageDataUrl = (content?: string): boolean => {
    if (!content) return false;
    return content.trim().startsWith('data:image/');
  };

  // NEW Helper to determine if content is a Power BI textual description
  const isPowerBITextDescription = (content?: string): boolean => {
    if (!content) return false;
    return content.trim().startsWith('Power BI Visual:') || content.trim().startsWith('The user is referencing a full Power BI report embedded via iframe');
  };

  // Setup speech recognition
  useEffect(() => {
    if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognitionRef.current = new SpeechRecognition();
      recognitionRef.current.continuous = true;
      recognitionRef.current.interimResults = true;

      recognitionRef.current.onresult = (event) => {
        const transcript = Array.from(event.results)
          .map(result => result[0])
          .map(result => result.transcript)
          .join('');

        setMessage(transcript);
      };

      recognitionRef.current.onerror = (event) => {
        console.error('Speech recognition error', event.error);
        setIsListening(false);
        toast({
          title: "Speech Recognition Error",
          description: "There was a problem with the microphone access."
        });
      };
    }

    return () => {
      if (recognitionRef.current) {
        recognitionRef.current.stop();
      }
    };
  }, [toast]);

  const toggleListening = () => {
    if (!recognitionRef.current) {
      toast({
        title: "Speech Recognition Not Supported",
        description: "Your browser doesn't support speech recognition."
      });
      return;
    }

    if (isListening) {
      recognitionRef.current.stop();
      setIsListening(false);
    } else {
      recognitionRef.current.start();
      setIsListening(true);
      toast({
        title: "Listening...",
        description: "Start speaking. Your words will appear in the text field."
      });
    }
  };

  // Auto-scroll to bottom of chat
  useEffect(() => {
    if (chatContainerRef.current) {
      const container = chatContainerRef.current;
      const scrollHeight = container.scrollHeight;
      const clientHeight = container.clientHeight;
      const currentScroll = container.scrollTop;

      // Only scroll to bottom if already near bottom
      if (scrollHeight - currentScroll <= clientHeight + 100) {
        container.scrollTop = scrollHeight;
      }
    }
  }, [chatHistory]);

  const handleMouseDown = (e: React.MouseEvent) => {
    setIsResizing(true);
    startXRef.current = e.clientX;
    startWidthRef.current = width;
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  };

  const handleMouseMove = (e: MouseEvent) => {
    if (isResizing) {
      const deltaX = e.clientX - startXRef.current;
      const newWidth = e.clientX < window.innerWidth / 2
        ? startWidthRef.current - deltaX
        : startWidthRef.current + deltaX;

      if (newWidth > 280 && newWidth < 800) {
        setWidth(newWidth);
      }
    }
  };

  const handleMouseUp = () => {
    setIsResizing(false);
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
  };

  const handleSendMessage = () => {
    if (message.trim()) {
      onSendMessage(message);
      setMessage('');

      if (isListening && recognitionRef.current) {
        recognitionRef.current.stop();
        setIsListening(false);
      }
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  return (
    <>
      {/* Resize handles - visible only when panel is open */}
      {isOpen && (
        <>
          <div
            className="absolute top-0 left-0 w-1 h-full cursor-ew-resize z-20 hover:bg-primary/10"
            onMouseDown={handleMouseDown}
          />
          <div
            className="absolute top-0 right-0 w-1 h-full cursor-ew-resize z-20 hover:bg-primary/10"
            onMouseDown={handleMouseDown}
          />
        </>
      )}

      <div
        className="fixed top-14 right-0 h-[calc(100vh-3.5rem)] bg-background border-l border-border transition-all duration-300 flex flex-col z-10 shadow-lg"
        style={{ width: isOpen ? `${width}px` : '40px' }}
      >
        {isOpen ? (
          <>
            <div className="flex items-center justify-between p-3 border-b">
              <h3 className="font-semibold">
                {selectedChart ? `Chat - ${selectedChart}` : 'AI Assistant'}
              </h3>
              <div className="flex">
                <Button variant="ghost" size="icon" onClick={onToggle}>
                  <ChevronRight className="h-4 w-4" />
                </Button>
                <Button variant="ghost" size="icon" onClick={onToggle}>
                  <X className="h-4 w-4" />
                </Button>
              </div>
            </div>

            <ScrollArea className="flex-1 p-4" ref={chatContainerRef}>
              <div className="space-y-4">
                {chatHistory.length > 0 ? (
                  chatHistory.map((chat, index) => (
                    <div
                      key={index}
                      className={`flex ${
                        chat.isUser ? 'justify-end' : 'justify-start'
                      }`}
                    >
                      <div
                        className={`max-w-[85%] p-3 rounded-lg ${
                          chat.isUser
                            ? 'bg-primary text-primary-foreground'
                            : 'bg-muted'
                        }`}
                      >
                        <div className="mt-2 flex items-center">
                          {chat.message}
                          {chat.isLoading && (
                            <Loader2 className="ml-2 h-4 w-4 animate-spin text-primary" />
                          )}
                        </div>

                        {/* Display chart content appropriately based on type */}
                        {chat.isUser && chat.chartContent && (
                          <div className="mt-3 border rounded overflow-hidden bg-background">
                            <div className="p-2 bg-muted/30 border-b text-xs font-medium">
                              Chart Reference
                            </div>
                            <div className="h-[150px] w-full flex items-center justify-center">
                              {isImageDataUrl(chat.chartContent) ? (
                                <img
                                  src={chat.chartContent}
                                  alt="Chart visualization"
                                  className="max-w-full max-h-full object-contain"
                                />
                              ) : isPowerBITextDescription(chat.chartContent) ? (
                                <div className="text-sm text-muted-foreground p-2 text-center break-words">
                                  {chat.chartContent}
                                </div>
                              ) : (
                                <ChartScreenshot htmlContent={chat.chartContent} />
                              )}
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  ))
                ) : (
                  <div className="flex flex-col items-center justify-center h-full text-center text-muted-foreground">
                    <p>Ask me questions about your data</p>
                    <div className="mt-4 grid grid-cols-1 gap-2">
                      {suggestions.map((suggestion, index) => (
                        <Button
                          key={index}
                          variant="secondary"
                          size="sm"
                          className="text-left justify-start"
                          onClick={() => {
                            onSendMessage(suggestion.question);
                          }}
                        >
                          {suggestion.question}
                        </Button>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </ScrollArea>

            <div className="p-3 border-t">
              <div className="flex space-x-2">
                <Textarea
                  value={message}
                  onChange={(e) => setMessage(e.target.value)}
                  onKeyDown={handleKeyDown}
                  placeholder="Type your question..."
                  className="resize-none"
                  rows={2}
                />
                <div className="flex flex-col space-y-2">
                  <Button
                    size="icon"
                    variant={isListening ? "destructive" : "secondary"}
                    onClick={toggleListening}
                    title={isListening ? "Stop listening" : "Start voice input"}
                  >
                    {isListening ? <MicOff className="h-4 w-4" /> : <Mic className="h-4 w-4" />}
                  </Button>
                  <Button size="icon" onClick={handleSendMessage}>
                    <Send className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            </div>
          </>
        ) : (
          <Button
            variant="ghost"
            size="icon"
            className="w-10 h-10"
            onClick={onToggle}
          >
            <ChevronLeft className="h-4 w-4" />
          </Button>
        )}
      </div>
    </>
  );
};

export default ChatbotPanel;

================
File: src/components/DraggableChartGrid.tsx
================
import { useState, useEffect, useCallback, useRef } from 'react';
import Chart from './Chart';
import { ChartType } from '@/types/chart';
import { PowerBiEmbedData } from '@/services/powerBiUtils';
import { Responsive, WidthProvider, Layout } from 'react-grid-layout';
import 'react-grid-layout/css/styles.css';
import * as pbi from 'powerbi-client';

const ResponsiveGridLayout = WidthProvider(Responsive);

interface DraggableChartGridProps {
  charts: ChartType[];
  isEditMode: boolean;
  onRemoveChart: (id: string) => void;
  onLayoutChange: (layout: Layout[]) => void;
  pageId: string;
  savedLayout?: { [key: string]: Layout[] };
  mainEmbedData: PowerBiEmbedData | null;
  // onAskQuestion now accepts question, chartId, chartDataForLLM, and chartContentForDisplay
  onAskQuestion: (question: string, chartId: string, chartDataForLLM?: string, chartContentForDisplay?: string) => void; // <--- MODIFIED
}

const DraggableChartGrid = ({
  charts,
  isEditMode,
  onRemoveChart,
  onLayoutChange,
  onAskQuestion,
  pageId,
  savedLayout,
  mainEmbedData
}: DraggableChartGridProps) => {
  const [currentLayout, setCurrentLayout] = useState<Layout[]>([]);
  const isInitialLoad = useRef(true);
  const prevPageId = useRef(pageId);

  const [activeFilters, setActiveFilters] = useState<Record<string, pbi.models.IFilter[]>>({});

  useEffect(() => {
    if (isInitialLoad.current || pageId !== prevPageId.current) {
      const layoutToApply = savedLayout?.lg || [];
      const filteredLayout = layoutToApply.filter((layoutItem: Layout) =>
        charts.some(chart => chart.id === layoutItem.i)
      );

      const chartIdsInLayout = new Set(filteredLayout.map(l => l.i));
      const chartsNotInLayout = charts.filter(c => !chartIdsInLayout.has(c.id));

      const defaultLayoutsForMissing = chartsNotInLayout.map((chart, index) => {
        const existingChartsCount = filteredLayout.length;
        const totalChartsCurrently = existingChartsCount + index;
        
        const cols = 12;
        const defaultW = chart.layout?.w || 6;
        const defaultH = chart.layout?.h || 10;
        
        const maxY = filteredLayout.reduce((max, item) => Math.max(max, item.y + item.h), 0);
        
        let x = (totalChartsCurrently * defaultW) % cols;
        let y = maxY + Math.floor(totalChartsCurrently * defaultW / cols) * defaultH;


        return {
          i: chart.id,
          x: x,
          y: y,
          w: defaultW,
          h: defaultH,
          minW: chart.layout?.minW || 4,
          minH: chart.layout?.minH || 6,
        };
      });
      const finalLayout = [...filteredLayout, ...defaultLayoutsForMissing];

      console.log(`[DraggableChartGrid-${pageId}] Initializing/re-initializing layout. Saved:`, savedLayout, "Final:", finalLayout);
      setCurrentLayout(finalLayout);
      onLayoutChange(finalLayout);

      isInitialLoad.current = false;
    }
    setActiveFilters({});
  }, [pageId, savedLayout, charts, onLayoutChange]);


  useEffect(() => {
    prevPageId.current = pageId;
  }, [pageId]);


  const handleLayoutChangeInternal = useCallback((layout: Layout[]) => {
    console.log('[DraggableChartGrid] RGL internal layout change:', layout);
    setCurrentLayout(layout);
    onLayoutChange(layout);
  }, [onLayoutChange]);


  const handleRemoveChart = useCallback((chartId: string) => {
    console.log('[DraggableChartGrid] Removing chart', chartId);

    setCurrentLayout(prevLayout => prevLayout.filter(item => item.i !== chartId));

    setActiveFilters(prev => {
      const newFilters = { ...prev };
      delete newFilters[chartId];
      return newFilters;
    });

    onRemoveChart(chartId);
  }, [onRemoveChart]);

  const handleVisualDataSelected = useCallback((sourceChartId: string, filters: pbi.models.IFilter[]) => {
    console.log(`[DraggableChartGrid] Data selected from ${sourceChartId}:`, filters);
    setActiveFilters(prev => {
      const newFilters = { ...prev };
      if (filters.length > 0) {
        newFilters[sourceChartId] = filters;
      } else {
        delete newFilters[sourceChartId];
      }
      return newFilters;
    });
  }, []);

  return (
    <div className="p-0 md:p-4">
      <ResponsiveGridLayout
        className="layout"
        layouts={{ lg: currentLayout }}
        breakpoints={{ lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 }}
        cols={{ lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 }}
        rowHeight={30}
        isDraggable={isEditMode}
        isResizable={isEditMode}
        onLayoutChange={handleLayoutChangeInternal}
        compactType="vertical"
        margin={[10, 10]}
        containerPadding={[0, 0]}
        draggableCancel=".chart-delete-button"
      >
        {charts.map((chart) => {
          const layoutItem = currentLayout.find(item => item.i === chart.id);
          if (!layoutItem) {
              console.warn(`[DraggableChartGrid] No layout found for chart ${chart.id}, skipping render.`);
              return null;
          }
          const filtersForThisChart = Object.entries(activeFilters)
            .filter(([id, _]) => id !== chart.id)
            .flatMap(([_ , f]) => f);

          return (
            <div key={chart.id} data-grid={layoutItem} className="h-full">
              <Chart
                chart={chart}
                isEditMode={isEditMode}
                onRemove={handleRemoveChart}
                onAskQuestion={onAskQuestion} // <--- No change here, just passes through
                mainEmbedData={mainEmbedData}
                currentFilters={filtersForThisChart}
                onVisualDataSelected={handleVisualDataSelected}
              />
            </div>
          );
        })}
      </ResponsiveGridLayout>
    </div>
  );
};

export default DraggableChartGrid;



================
File: src/components/ModalWindow.tsx
================
// src/components/ModalWindow.tsx
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogClose } from '@/components/ui/dialog'; // Using shadcn dialog
import { Checkbox } from '@/components/ui/checkbox';
import { Label } from '@/components/ui/label';

// This Report interface should match what your backend/selection list provides
export interface Report {
  id: number | string; // Allow string for more flexibility
  title: string;
  description: string;
  category?: string; // Optional, if you use categories for filtering
  // Add any other relevant fields like pageName, visualName if known at this stage
  // Or rely on the DYNAMIC_PBI_CONFIG_MAP in Dashboard.tsx
}

interface ModalWindowProps {
  isOpen: boolean;
  onClose: () => void;
  onAdd: (reports: Report[]) => void;
}

// Mock list of reports that can be added dynamically.
// In a real app, this might come from an API.
const availableDynamicReports: Report[] = [
  { id: 1, title: 'Category Breakdown', description: 'PBI: Detailed view of sales by category.' },
  { id: 2, title: 'Revenue Trends', description: 'PBI: Analysis of revenue over time.' },
  { id: 3, title: 'Store Breakdown', description: 'PBI: Performance metrics per store.' },
  // Add more potential dynamic reports here
];

const ModalWindow: React.FC<ModalWindowProps> = ({ isOpen, onClose, onAdd }) => {
  const [selectedReportIds, setSelectedReportIds] = useState<(number | string)[]>([]);

  const handleToggleReport = (reportId: number | string) => {
    setSelectedReportIds(prev =>
      prev.includes(reportId)
        ? prev.filter(id => id !== reportId)
        : [...prev, reportId]
    );
  };

  const handleAddClick = () => {
    const reportsToAdd = availableDynamicReports.filter(report =>
      selectedReportIds.includes(report.id)
    );
    onAdd(reportsToAdd);
    setSelectedReportIds([]); // Clear selection after adding
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <DialogContent className="sm:max-w-[600px]">
        <DialogHeader>
          <DialogTitle>Add Power BI Visuals to Dashboard</DialogTitle>
        </DialogHeader>
        <div className="py-4 max-h-[60vh] overflow-y-auto">
          <div className="space-y-4">
            {availableDynamicReports.map(report => (
              <div
                key={report.id}
                className="flex items-center space-x-3 p-3 rounded-md border hover:bg-accent hover:text-accent-foreground cursor-pointer data-[state=checked]:bg-accent"
                onClick={() => handleToggleReport(report.id)}
                data-state={selectedReportIds.includes(report.id) ? "checked" : "unchecked"}
              >
                <Checkbox
                  id={`report-${report.id}`}
                  checked={selectedReportIds.includes(report.id)}
                  onCheckedChange={() => handleToggleReport(report.id)}
                />
                <div className="flex-1">
                  <Label htmlFor={`report-${report.id}`} className="font-medium cursor-pointer">
                    {report.title}
                  </Label>
                  <p className="text-sm text-muted-foreground">{report.description}</p>
                </div>
              </div>
            ))}
          </div>
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={onClose}>Cancel</Button>
          <Button onClick={handleAddClick} disabled={selectedReportIds.length === 0}>
            Add Selected ({selectedReportIds.length})
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export { ModalWindow }; // Named export



================
File: src/components/PageTabs.tsx
================
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Plus, X, Settings } from 'lucide-react';
import { DashboardPage } from '@/types/page';
import { useToast } from '@/hooks/use-toast';

interface PageTabsProps {
  pages: DashboardPage[];
  currentPageId: string;
  onPageChange: (pageId: string) => void;
  onAddPage: (name: string) => void;
  onDeletePage: (pageId: string) => void;
  isEditMode: boolean;
}

const PageTabs = ({ 
  pages, 
  currentPageId, 
  onPageChange, 
  onAddPage, 
  onDeletePage,
  isEditMode
}: PageTabsProps) => {
  const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);
  const [newPageName, setNewPageName] = useState('');
  const { toast } = useToast();

  const handleAddPage = () => {
    if (newPageName.trim()) {
      onAddPage(newPageName.trim());
      setNewPageName('');
      setIsAddDialogOpen(false);
      toast({
        title: "Page added",
        description: `${newPageName} has been created`,
      });
    }
  };

  const handleDeletePage = (pageId: string, pageName: string) => {
    onDeletePage(pageId);
    toast({
      title: "Page deleted",
      description: `${pageName} has been removed`,
    });
  };

  return (
    <div className="border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="flex items-center justify-between p-4">
        <Tabs value={currentPageId} onValueChange={onPageChange} className="flex-1">
          <TabsList className="grid w-full grid-cols-auto">
            {pages.map((page) => (
              <div key={page.id} className="flex items-center">
                <TabsTrigger 
                  value={page.id} 
                  className="relative group"
                >
                  {page.name}
                  {isEditMode && !page.isDefault && (
                    <Button
                      variant="ghost"
                      size="sm"
                      className="ml-2 h-4 w-4 p-0 opacity-0 group-hover:opacity-100 transition-opacity"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleDeletePage(page.id, page.name);
                      }}
                    >
                      <X className="h-3 w-3" />
                    </Button>
                  )}
                </TabsTrigger>
              </div>
            ))}
          </TabsList>
        </Tabs>

        <Dialog open={isAddDialogOpen} onOpenChange={setIsAddDialogOpen}>
          <DialogTrigger asChild>
            <Button variant="outline" size="sm" className="ml-4">
              <Plus className="h-4 w-4 mr-2" />
              Add Page
            </Button>
          </DialogTrigger>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Add New Page</DialogTitle>
            </DialogHeader>
            <div className="space-y-4">
              <div>
                <Label htmlFor="page-name">Page Name</Label>
                <Input
                  id="page-name"
                  value={newPageName}
                  onChange={(e) => setNewPageName(e.target.value)}
                  placeholder="Enter page name..."
                  onKeyDown={(e) => {
                    if (e.key === 'Enter') {
                      handleAddPage();
                    }
                  }}
                />
              </div>
              <div className="flex justify-end space-x-2">
                <Button variant="outline" onClick={() => setIsAddDialogOpen(false)}>
                  Cancel
                </Button>
                <Button onClick={handleAddPage} disabled={!newPageName.trim()}>
                  Add Page
                </Button>
              </div>
            </div>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  );
};

export default PageTabs;

================
File: src/components/PowerBIReport.tsx
================
import React from 'react';
import { Card, CardContent } from '@/components/ui/card';

interface PowerBIReportProps {
  url: string;
  title: string;
}

const PowerBIReport = ({ url, title }: PowerBIReportProps) => {
  // Ensure the URL is properly formatted and not being modified
  const safeUrl = url.trim();
  
  return (
    <Card className="w-full h-full overflow-hidden">
      <CardContent className="p-0 h-full">
        <iframe
          src={safeUrl}
          title={title}
          width="100%"
          height="100%"
          style={{ border: "none" }}
          allowFullScreen
        />
      </CardContent>
    </Card>
  );
};

export default PowerBIReport;



================
File: src/data/mockCharts.tsx
================
// src/data/mockCharts.tsx
import { ChartType } from '@/types/chart';
import { AlignEndHorizontal, Activity, LayoutDashboard, DollarSign, Users, TrendingUp } from 'lucide-react';

export const mockCharts: ChartType[] = [
  {
    id: 'conversion-funnel',
    name: 'Conversion Funnel (PBI)',
    type: 'powerbi',
    content: 'A Power BI visual showing the customer conversion funnel.',
    icon: <AlignEndHorizontal className="h-5 w-5 " style={{ color: '#a985db' }} />,
    layout: { i: 'conversion-funnel', x: 0, y: 0, w: 6, h: 10, minW: 4, minH: 6 }, // Corrected w=6
    powerBiConfig: {
      pageName: 'ReportSection4b3fbaa7dd7908d906d9',
      visualName: '3a28c5fee26bd29ff352',
    },
    askableQuestions: [
      'Summarize conversion rates',
      'What are the drop-off points in the funnel?',
      'Show conversion rates by stage.'
    ],
  },
  {
    id: 'pbi-marketing-performance-visual',
    name: 'Marketing Performance (PBI)',
    type: 'powerbi',
    content: 'A Power BI visual showing marketing campaign performance metrics.',
    icon: <TrendingUp className="h-5 w-5 " style={{ color: '#a985db' }} />,
    layout: { i: 'pbi-marketing-performance-visual', x: 6, y: 20, w: 6, h: 10, minW: 4, minH: 6 }, // Corrected w=6, x=6
    powerBiConfig: {
      pageName: 'ReportSection4b3fbaa7dd7908d906d9',
      visualName: '3a28c5fee26bd29ff352',
    },
    askableQuestions: [
      'Analyze ROI of recent campaigns.',
      'Which channels are performing best?',
      'Show customer acquisition cost trends.'
    ],
  },
  {
    id: 'overview-pbi-revenue-trends-visual',
    name: 'Sales Summary (PBI) - Revenue Trends',
    type: 'powerbi',
    content: 'A Power BI visual showing revenue trends over time.',
    icon: <DollarSign className="h-5 w-5 " style={{ color: '#a985db' }} />,
    layout: { i: 'overview-pbi-revenue-trends-visual', x: 0, y: 10, w: 6, h: 10, minW: 4, minH: 6 }, // Corrected w=6
    powerBiConfig: {
      pageName: 'ReportSection998e2850a99cabad87e8',
      visualName: '3a28c5fee26bd29ff352',
    },
    askableQuestions: ['What are the key revenue trends?', 'How has revenue changed over time?'],
  },
  {
    id: 'pbi-store-breakdown-visual',
    name: 'Sales Summary (PBI) - Store Breakdown',
    type: 'powerbi',
    content: 'A Power BI visual showing sales performance metrics per store.',
    icon: <DollarSign className="h-5 w-5 " style={{ color: '#a985db' }} />,
    layout: { i: 'pbi-store-breakdown-visual', x: 6, y: 10, w: 6, h: 10, minW: 4, minH: 6 }, // Corrected w=6, x=6
    powerBiConfig: {
      pageName: 'ReportSection4b3fbaa7dd7908d906d9',
      visualName: 'd55aa7aa40745de10d55',
    },
    askableQuestions: [
      'Which stores have the highest revenue?',
      'Analyze store performance by region.',
      'Show store sales trends.'
    ],
  },
  {
    id: 'pbi-customer-demographics-visual',
    name: 'Customer Demographics (PBI)',
    type: 'powerbi',
    content: 'A Power BI visual displaying customer demographic information.',
    icon: <Users className="h-5 w-5 " style={{ color: '#a985db' }} />,
    layout: { i: 'pbi-customer-demographics-visual', x: 0, y: 20, w: 6, h: 10, minW: 4, minH: 6 }, // Corrected w=6
    powerBiConfig: {
      pageName: 'ReportSectiona37d01e834c17d07bbeb',
      visualName: 'b33397810d555ca70a8c',
    },
    askableQuestions: [
      'What is the age distribution of customers?',
      'Show customer segmentation by income.',
      'Analyze customer locations.'
    ],
  },
  // Add a 6th visual if you want a complete 2x3 grid (3 rows of 2 visuals)
  {
    id: 'overview-pbi-category-breakdown-visual',
    name: 'Sales Summary (PBI) - Category Breakdown',
    type: 'powerbi',
    content: 'A Power BI visual showing sales summary by product category.',
    icon: <LayoutDashboard className="h-5 w-5 " style={{ color: '#a985db' }} />,
    layout: { i: 'overview-pbi-category-breakdown-visual', x: 6, y: 0, w: 6, h: 10, minW: 4, minH: 6 }, // Corrected w=6, x=6
    powerBiConfig: {
      pageName: 'ReportSectiona37d01e834c17d07bbeb',
      visualName: '805719ca6000cb000be2',
    },
    askableQuestions: ['What are the total sales by category?', 'Show sales by product category.'],
  },
];



================
File: src/hooks/usePageManager.ts
================
// src/hooks/usePageManager.ts
import { useState, useEffect, useMemo, useCallback } from 'react';
import { DashboardPage } from '@/types/page';
import { Layout } from 'react-grid-layout'; // Import Layout type for clarity

// Define a type for the setIsEditMode function
type SetIsEditMode = (value: boolean | ((prevState: boolean) => boolean)) => void;

const DEFAULT_PAGES: DashboardPage[] = [
  {
    id: 'finance',
    name: 'Finance',
    charts: [
      'overview-pbi-revenue-trends-visual',
      'pbi-store-breakdown-visual'
    ],
    isDefault: true,
    layout: {}
  },
  {
    id: 'hr',
    name: 'HR',
    charts: [
      'pbi-customer-demographics-visual',
      'conversion-funnel'
    ],
    isDefault: true,
    layout: {}
  },
  {
    id: 'operations',
    name: 'Operations',
    charts: [
      'overview-pbi-category-breakdown-visual',
      'pbi-marketing-performance-visual'
    ],
    isDefault: true,
    layout: {}
  },
  {
    id: 'overview',
    name: 'Overview',
    charts: [
      'conversion-funnel',
      'overview-pbi-category-breakdown-visual',
      'overview-pbi-revenue-trends-visual',
      'pbi-store-breakdown-visual',
      'pbi-customer-demographics-visual',
      'pbi-marketing-performance-visual'
    ],
    isDefault: true,
    layout: {}
  }
];

// Accept setIsEditMode as a parameter
export const usePageManager = (setIsEditMode: SetIsEditMode) => {
  const [pages, setPages] = useState<DashboardPage[]>(() => {
    try {
      const savedPages = localStorage.getItem('dashboard-pages');
      if (savedPages) {
        const parsedPages = JSON.parse(savedPages) as DashboardPage[];
        const ensuredPages = DEFAULT_PAGES.map(defaultPage => {
          const savedVersion = parsedPages.find(p => p.id === defaultPage.id);
          if (savedVersion) {
              const newChartsToAdd = defaultPage.charts.filter(
                  chartId => !savedVersion.charts.includes(chartId)
              );
              if (newChartsToAdd.length > 0) {
                  return { ...savedVersion, charts: [...savedVersion.charts, ...newChartsToAdd] };
              }
              return savedVersion;
          }
          return defaultPage;
        });
        parsedPages.forEach(savedPage => {
          if (!ensuredPages.some(p => p.id === savedPage.id)) {
            ensuredPages.push(savedPage);
          }
        });
        return ensuredPages;
      }
    } catch (err) {
      console.error('Failed to load saved pages, using defaults:', err);
    }
    return DEFAULT_PAGES;
  });
  const [currentPageId, setCurrentPageId] = useState('overview');

  // Memoize currentPage to prevent unnecessary re-renders of components depending on it
  // and to ensure a stable reference for its 'layout' property.
  const currentPage = useMemo(() => {
    const page = pages.find(p => p.id === currentPageId);
    if (page) return page;
    // Fallback if currentPageId is invalid or page is not found (shouldn't happen often)
    console.warn(`[usePageManager] Current page with ID "${currentPageId}" not found. Falling back to default.`);
    return pages.length > 0 ? pages[0] : DEFAULT_PAGES[0];
  }, [pages, currentPageId]);

  // Effect to load initial currentPageId from localStorage
  useEffect(() => {
    const savedCurrentPageId = localStorage.getItem('dashboard-current-page-id');
    if (savedCurrentPageId && pages.some(p => p.id === savedCurrentPageId)) {
      setCurrentPageId(savedCurrentPageId);
    } else if (pages.length > 0) {
      setCurrentPageId(pages[0].id);
    }
  }, [pages]);
  

  useEffect(() => {
    try {
      localStorage.setItem('dashboard-pages', JSON.stringify(pages));
      localStorage.setItem('dashboard-current-page-id', currentPageId);
    } catch (err) {
      console.error('Failed to save pages or currentPageId:', err);
    }
  }, [pages, currentPageId]);

  const addPage = (name: string) => {
    const newPage: DashboardPage = {
      id: `page-${Date.now()}`,
      name,
      charts: [], // New pages start empty by default
      isDefault: false,
      layout: {} as { [key: string]: Layout[] } // Explicitly type layout
    };
    setPages(prev => [...prev, newPage]);
    setCurrentPageId(newPage.id);
    setIsEditMode(true); // <--- Automatically turn on edit mode for new page
  };

  const deletePage = (pageId: string) => {
    const pageToDelete = pages.find(p => p.id === pageId);
    if (pageToDelete?.isDefault && pages.filter(p=>p.isDefault).length === 1) {
        console.warn("Cannot delete the last default page.");
        return;
    }

    setPages(prev => {
      const newPages = prev.filter(p => p.id !== pageId);
      if (currentPageId === pageId) {
        setCurrentPageId(newPages.length > 0 ? newPages[0].id : (DEFAULT_PAGES[0]?.id || 'overview'));
      }
      return newPages;
    });
  };

  const updatePageCharts = useCallback((pageId: string, chartIds: string[]) => {
    setPages(prev => prev.map(page =>
      page.id === pageId ? { ...page, charts: chartIds } : page
    ));
  }, []);

  // Memoize updatePageLayout to prevent unnecessary re-renders and ensure stable function reference
  const updatePageLayout = useCallback((pageId: string, layout: { lg: Layout[] }) => {
    setPages(prev => prev.map(page => {
      if (page.id === pageId) {
        // Perform a simple deep comparison to avoid unnecessary state updates if layout is identical
        const currentLayoutJson = JSON.stringify(page.layout);
        const newLayoutJson = JSON.stringify(layout);
        if (currentLayoutJson !== newLayoutJson) {
          console.log(`[usePageManager] Updating layout for page ${pageId}`);
          return { ...page, layout };
        } else {
          console.log(`[usePageManager] Layout for page ${pageId} is identical, skipping update.`);
        }
      }
      return page;
    }));
  }, []); // Empty dependency array ensures this callback is stable

  return {
    pages,
    currentPageId,
    setCurrentPageId,
    addPage,
    deletePage,
    updatePageCharts,
    updatePageLayout, // Export memoized function
    currentPage,      // Export memoized current page object
  };
};

================
File: src/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: src/pages/Dashboard.tsx
================
// src/pages/Dashboard.tsx
import { useState, useEffect, useRef, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import Navbar from '@/components/Navbar';
import EnhancedSidebar from '@/components/EnhancedSidebar';
import PageSidebar from '@/components/PageSidebar';
import ChatbotPanel from '@/components/ChatbotPanel';
import DraggableChartGrid from '@/components/DraggableChartGrid';
import { Layout as RGL_Layout } from 'react-grid-layout';
import { mockCharts as initialMockCharts } from '@/data/mockCharts';
import { ChartType, PowerBiConfig } from '@/types/chart';
import { ChatMessage, ChatSuggestion } from '@/types/chat'; // Ensure ChatMessage has isLoading
import { useToast } from '@/hooks/use-toast';
import { usePageManager } from '@/hooks/usePageManager';
import { ScrollArea } from '@/components/ui/scroll-area';
import { SidebarProvider, SidebarInset } from '@/components/ui/sidebar';
import { fetchMainEmbedData, PowerBiEmbedData } from '@/services/powerBiUtils';
import { ModalWindow, Report as ModalReport } from '@/components/ModalWindow';
import { Button } from '@/components/ui/button';

// Add the API base URL from Vite environment variables
const API_BASE_URL = import.meta.env.VITE_YOUR_BACKEND_API_URL || 'http://localhost:3000';

const DEFAULT_SUGGESTIONS: ChatSuggestion[] = [
  { question: 'What is the current overall revenue trend?' },
  { question: 'Summarize key sales metrics for this quarter.' },
  { question: 'Show me customer demographics by age group.' },
  { question: 'How is marketing campaign performance looking?' },
  { question: 'Analyze conversion rates across different channels.' },
];
const DYNAMIC_PBI_CONFIG_MAP: Record<string, PowerBiConfig> = {
  "Category Breakdown": { pageName: "ReportSection998e2850a99cabad87e8", visualName: "3a28c5fee26bd29ff352" },
  "Revenue Trends": { pageName: "ReportSection998e2850a99cabad87e8", visualName: "d55aa7aa40745de10d55" },
  "Store Breakdown": { pageName: "ReportSection4b3fbaa7dd7908d906d9", visualName: "3a28c5fee26bd29ff352" },
};

// Helper function to get auth token
const getAuthToken = (): string | null => {
  const userString = localStorage.getItem('user');
  if (!userString) {
    console.log("[getAuthToken] No 'user' item found in localStorage.");
    return null;
  }
  try {
    const parsedUser = JSON.parse(userString);
    if (parsedUser && typeof parsedUser === 'object' && 'id_token' in parsedUser) {
      if (parsedUser.id_token) {
        console.log("[getAuthToken] ID Token found in localStorage.");
        return parsedUser.id_token;
      } else {
        console.warn("[getAuthToken] 'user' object found but 'id_token' is empty or null. User data:", parsedUser);
        return null;
      }
    } else {
      console.warn("[getAuthToken] 'user' object in localStorage is not a valid object or does not contain 'id_token'. User data:", parsedUser);
      return null;
    }
  } catch (e) {
    console.error("[getAuthToken] Failed to parse 'user' from localStorage. Error:", e, "Raw data:", userString);
    return null;
  }
};

// Helper function to map frontend chat history to LLM expected format
const mapChatHistoryToLLMFormat = (history: ChatMessage[]) => {
  return history.map(msg => ({
    role: msg.isUser ? 'user' : 'assistant',
    content: msg.message,
  })).filter(msg => msg.content.trim() !== ''); // Filter out empty messages
};


const Dashboard = () => {
  const [isEditMode, setIsEditMode] = useState(false);
  const [isChatOpen, setIsChatOpen] = useState(false);
  const [allCharts, setAllCharts] = useState<ChartType[]>([]);
  const [chatHistory, setChatHistory] = useState<ChatMessage[]>([]);
  const [selectedChartForAI, setSelectedChartForAI] = useState<string | undefined>(undefined);

  const navigate = useNavigate();
  const { toast } = useToast();
  const {
    pages, currentPageId, setCurrentPageId, addPage, deletePage,
    updatePageCharts, updatePageLayout, currentPage
  } = usePageManager(setIsEditMode);

  const [mainEmbedData, setMainEmbedData] = useState<PowerBiEmbedData | null>(null);
  const [isAddPbiModalOpen, setIsAddPbiModalOpen] = useState(false);
  const isMounted = useRef(true);

  useEffect(() => {
    return () => {
      isMounted.current = false;
    };
  }, []);

  useEffect(() => {
    console.log('[Dashboard] Auth effect running.');
    const user = localStorage.getItem('user');
    if (!user) {
      console.log('[Dashboard] No user found, navigating to /login.');
      navigate('/login');
    } else {
      console.log('[Dashboard] User found, fetching main PBI embed data.');
      fetchMainEmbedData()
        .then(data => {
          setMainEmbedData(data);
        })
        .catch(error => {
          console.error("[Dashboard] Failed to get PBI embed data:", error);
          toast({ title: "Power BI Error", description: "Could not load Power BI configuration.", variant: "destructive" });
        });
    }
  }, [navigate, toast]);

  useEffect(() => {
    console.log('[Dashboard] Initializing allCharts from mockData.');
    const processedInitialCharts = initialMockCharts.map(chart => {
      if (chart.id === 'power-bi-report') {
        return { ...chart, id: 'power-bi-report-iframe', name: 'Power BI Report (Full Iframe)' };
      }
      return chart;
    });
    console.log('[Dashboard] Processed initial charts:', processedInitialCharts.map(c => ({id: c.id, type: c.type, name: c.name})));
    setAllCharts(processedInitialCharts);
  }, []);

  const visibleCharts = useMemo(() => {
    if (!currentPage) {
      console.log('[Dashboard] visibleCharts: currentPage is null/undefined.');
      return [];
    }
    const charts = allCharts.filter(chart => currentPage.charts.includes(chart.id));
    console.log(`[Dashboard] visibleCharts for page ${currentPage.id}:`, charts.map(c => ({id: c.id, type: c.type, name: c.name})));
    return charts;
  }, [allCharts, currentPage]);


  const toggleEditMode = () => {
      setIsEditMode(!isEditMode);
      if (isEditMode) {
          toast({ title: "Layout Saved", description: "Dashboard layout has been saved." });
      }
  };

  const toggleChartVisibility = (chartId: string) => {
    console.log(`[Dashboard] toggleChartVisibility for ${chartId}`);
    const currentChartIds = currentPage?.charts || [];
    const chartMeta = allCharts.find(c => c.id === chartId);
    if (!chartMeta) return;

    if (currentChartIds.includes(chartId)) {
      updatePageCharts(currentPageId, currentChartIds.filter((id: string) => id !== chartId));
      toast({ title: "Chart Hidden", description: `${chartMeta.name} removed from this page.` });
    } else {
      updatePageCharts(currentPageId, [...currentChartIds, chartId]);
      toast({ title: "Chart Added", description: `${chartMeta.name} added to this page.` });
    }
  };
  const addChartToPage = (chartId: string) => {
    console.log(`[Dashboard] addChartToPage for ${chartId}`);
    const currentChartIds = currentPage?.charts || [];
      const chartMeta = allCharts.find(c => c.id === chartId);
      if (chartMeta && !currentChartIds.includes(chartId)) {
          updatePageCharts(currentPageId, [...currentChartIds, chartId]);
          toast({ title: "Chart Added", description: `${chartMeta.name} added to ${currentPage?.name}` });
      }
  };
  const removeChartFromPage = (chartId: string) => {
    console.log(`[Dashboard] removeChartFromPage for ${chartId}`);
    const chartMeta = allCharts.find(c => c.id === chartId);
    updatePageCharts(currentPageId, (currentPage?.charts || []).filter((id: string) => id !== chartId));
    if (selectedChartForAI === chartMeta?.name) {
      setSelectedChartForAI(undefined);
    }
    toast({ title: "Chart Removed", description: `${chartMeta?.name || 'Chart'} removed from ${currentPage?.name}` });
  };

  const handleLayoutChange = (newLayout: RGL_Layout[]) => {
    console.log('[Dashboard] handleLayoutChange:', newLayout);
    updatePageLayout(currentPageId, { lg: newLayout });
  };

  // Function to handle sending message and receiving streaming response
  const sendChatMessage = async (
    userInput: string,
    chartDataForLLM: string | undefined, // <--- MODIFIED: New parameter for LLM data
    chartContentForDisplay: string | undefined, // <--- MODIFIED: Renamed for clarity
    chartName?: string
  ) => {
    setIsChatOpen(true);
    setSelectedChartForAI(chartName);

    // Add user message to history
    setChatHistory(prev => [
      ...prev,
      { message: userInput, isUser: true, chartContent: chartContentForDisplay }, // <--- MODIFIED: Use chartContentForDisplay
    ]);

    // Add placeholder AI message
    const aiMessageIndex = chatHistory.length + 1; // Index where the AI message will be after user message
    setChatHistory(prev => [
      ...prev,
      { message: '', isUser: false, isLoading: true },
    ]);

    const authToken = getAuthToken();
    if (!authToken) {
      toast({ title: "Authentication Error", description: "Please log in to use AI assistant.", variant: "destructive" });
      setChatHistory(prev => prev.map((msg, idx) => idx === aiMessageIndex ? { ...msg, message: 'Authentication failed. Please log in.', isLoading: false } : msg));
      return;
    }

    try {
      const response = await fetch(`${API_BASE_URL}/llm-response`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${authToken}` // Include auth token
        },
        body: JSON.stringify({
          userInput: userInput,
          data: chartDataForLLM || "No specific chart data provided.", // <--- MODIFIED: Send chartDataForLLM to backend
          messages: mapChatHistoryToLLMFormat(chatHistory), // Send existing chat history
        }),
      });

      if (!response.ok) {
        const errorBody = await response.json();
        console.error("LLM API error:", errorBody);
        toast({ title: "AI Error", description: `Failed to get AI response: ${errorBody.details || errorBody.message || response.statusText}`, variant: "destructive" });
        setChatHistory(prev => prev.map((msg, idx) => idx === aiMessageIndex ? { ...msg, message: `Error: ${errorBody.details || 'Failed to get response.'}`, isLoading: false } : msg));
        return;
      }

      if (!response.body) {
        console.warn("LLM API returned no body.");
        setChatHistory(prev => prev.map((msg, idx) => idx === aiMessageIndex ? { ...msg, message: 'No response from AI.', isLoading: false } : msg));
        return;
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder('utf-8');
      let accumulatedContent = '';

      // The following stream processing logic is commented out because the mock response
      // requirement overrides actually consuming the SSE stream.
      // If you want to switch to real streaming, uncomment this and remove the mock logic above.

      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          console.log('Stream complete');
          break;
        }
        const chunk = decoder.decode(value, { stream: true });
        // SSE chunks typically look like: "data: {json_payload}\n\n"
        // We need to parse the JSON content from the 'data:' line
        chunk.split('\n').forEach(line => {
          if (line.startsWith('data: ')) {
            try {
              const jsonString = line.substring(6);
              if (jsonString === '[DONE]') { // Check for OpenAI stream end signal
                  console.log('OpenAI stream DONE.');
                  return;
              }
              const parsed = JSON.parse(jsonString);
              const content = parsed.choices?.[0]?.delta?.content;
              if (content) {
                accumulatedContent += content;
                setChatHistory(prev => prev.map((msg, idx) => idx === aiMessageIndex ? { ...msg, message: accumulatedContent, isLoading: true } : msg));
              }
            } catch (parseError) {
              console.warn("Failed to parse SSE data chunk:", parseError, "Chunk:", line);
            }
          }
        });
      }

      setChatHistory(prev => prev.map((msg, idx) => idx === aiMessageIndex ? { ...msg, isLoading: false } : msg));

    } catch (error) {
      console.error("Fetch or stream error:", error);
      toast({ title: "Network Error", description: "Could not connect to AI service.", variant: "destructive" });
      setChatHistory(prev => prev.map((msg, idx) => idx === aiMessageIndex ? { ...msg, message: 'Network error or AI service unreachable.', isLoading: false } : msg));
    }
  };

  const handleSendMessageToAI = (message: string) => {
    // Clear any selected chart context for general questions
    sendChatMessage(message, undefined, undefined, undefined); // <--- MODIFIED: pass undefined for data/display content
  };

  const handleAskQuestionAboutChart = (
    question: string,
    chartId: string,
    chartDataForLLM?: string, // <--- NEW: Accept data for LLM
    chartContentForDisplay?: string // <--- MODIFIED: Accept content for display
  ) => {
    const chartMeta = allCharts.find(c => c.id === chartId);
    // Send chart-specific question, passing chart content and name
    sendChatMessage(question, chartDataForLLM, chartContentForDisplay, chartMeta?.name); // <--- MODIFIED
  };

  const handleAddDynamicPbiReports = (reportsFromModal: ModalReport[]) => {
    console.log('[Dashboard] handleAddDynamicPbiReports called with:', reportsFromModal);
    const newPbiCharts: ChartType[] = [];
    const newChartIdsForPage: string[] = [];

    reportsFromModal.forEach(modalReport => {
      const dynamicChartId = `dynamic-pbi-${modalReport.id}`;
      console.log(`[Dashboard] Processing modal report: ${modalReport.title}, target ID: ${dynamicChartId}`);

      if (allCharts.some(c => c.id === dynamicChartId)) {
        console.log(`[Dashboard] Chart ${dynamicChartId} already in allCharts.`);
        if (!currentPage?.charts.includes(dynamicChartId)) {
            newChartIdsForPage.push(dynamicChartId);
            console.log(`[Dashboard] Adding existing chart ${dynamicChartId} to current page.`);
        }
        return;
      }

      const pbiConfig = DYNAMIC_PBI_CONFIG_MAP[modalReport.title] || DYNAMIC_PBI_CONFIG_MAP[String(modalReport.id)];
      if (!pbiConfig) {
        console.warn(`[Dashboard] No PBI config found for "${modalReport.title}". Cannot add.`);
        toast({ title: "Config Missing", description: `No Power BI config found for "${modalReport.title}". Cannot add.`, variant: "destructive" });
        return;
      }
      console.log(`[Dashboard] Found PBI config for ${modalReport.title}:`, pbiConfig);

      const newChart: ChartType = {
        id: dynamicChartId,
        name: modalReport.title,
        type: 'powerbi',
        content: modalReport.description || `Dynamically added Power BI visual: ${modalReport.title}`,
        icon: <span className="text-purple-500"></span>,
        layout: {
          i: dynamicChartId,
          x: ( (currentPage?.charts.length || 0) * 6 ) % 12, // Use 6 for 2 columns per row
          y: Infinity,
          w: 6, h: 10, minW: 3, minH: 6 // Increased default width/height for PBI
        },
        askableQuestions: [
          `Summarize ${modalReport.title}`,
          `What are the key trends in ${modalReport.title}?`
        ],
        isDynamicPBI: true,
      };
      console.log(`[Dashboard] Created new PBI chart object:`, newChart);
      newPbiCharts.push(newChart);
      newChartIdsForPage.push(newChart.id);
    });

    if (newPbiCharts.length > 0) {
      console.log('[Dashboard] Adding new PBI charts to allCharts state:', newPbiCharts);
      setAllCharts(prevAll => [...prevAll, ...newPbiCharts]);
    }
    if (newChartIdsForPage.length > 0) {
      console.log('[Dashboard] Adding new chart IDs to current page:', newChartIdsForPage);
      updatePageCharts(currentPageId, [...(currentPage?.charts || []), ...newChartIdsForPage]);
      toast({ title: "Reports Added", description: `${newChartIdsForPage.length} Power BI visual(s) added.` });
    }
    setIsAddPbiModalOpen(false);
  };


  return (
    <SidebarProvider>
      <div className="flex h-screen w-full overflow-hidden bg-gray-50 dark:bg-gray-900">
        <PageSidebar
          pages={pages}
          currentPageId={currentPageId}
          onPageChange={(pageId) => { console.log(`[Dashboard] Page changed to: ${pageId}`); setCurrentPageId(pageId);}}
          onAddPage={addPage}
          onDeletePage={deletePage}
          isEditMode={isEditMode}
        />

        <SidebarInset className="flex flex-col">
          <Navbar onToggleEditMode={toggleEditMode} isEditMode={isEditMode} />

          <div className="flex flex-1 overflow-hidden">
            <EnhancedSidebar
              availableCharts={allCharts}
              pageChartIds={currentPage?.charts || []}
              onToggleChart={toggleChartVisibility}
              onAddChart={addChartToPage}
              isEditMode={isEditMode}
              isCurrentPageDefault={currentPage?.isDefault || false}
            />

            <main className="flex-1 overflow-hidden relative bg-gray-50 dark:bg-gray-800">
              <ScrollArea className="h-full w-full">
                <div className="p-4 md:p-6">
                    {/* Hide "Add Power BI Visual" button if on a default page */}
                    {isEditMode && !currentPage?.isDefault && (
                        <div className="mb-4 text-right">
                            <Button onClick={() => setIsAddPbiModalOpen(true)}>Add Power BI Visual</Button>
                        </div>
                    )}

                  {visibleCharts.length > 0 ? (
                    <DraggableChartGrid
                      charts={visibleCharts}
                      isEditMode={isEditMode}
                      onRemoveChart={removeChartFromPage}
                      onLayoutChange={handleLayoutChange}
                      onAskQuestion={handleAskQuestionAboutChart} // <--- MODIFIED: This now passes more args
                      pageId={currentPageId}
                      savedLayout={currentPage?.layout}
                      mainEmbedData={mainEmbedData}
                    />
                  ) : (
                    <div className="flex items-center justify-center h-[calc(100vh-10rem)]">
                      <div className="text-center space-y-4 p-8">
                        <div className="text-6xl opacity-20"></div>
                        <h3 className="text-2xl font-semibold text-gray-600 dark:text-gray-300">
                          {currentPage?.name} is Empty
                        </h3>
                        <p className="text-gray-500 dark:text-gray-400 max-w-md">
                          {isEditMode && !currentPage?.isDefault
                            ? "Select charts from the sidebar or 'Add Power BI Visual' to customize this page."
                            : "Switch to 'Edit Mode' (top right) to add visuals to this page."
                          }
                          {isEditMode && currentPage?.isDefault && (
                             "You can rearrange existing charts in edit mode, but cannot add/remove visuals on default pages."
                          )}
                          {!isEditMode && currentPage?.isDefault && (
                            "This is a default page. Switch to 'Edit Mode' (top right) to rearrange existing visuals."
                          )}
                        </p>
                      </div>
                    </div>
                  )}
                </div>
              </ScrollArea>
            </main>

            <ChatbotPanel
              isOpen={isChatOpen}
              onToggle={() => setIsChatOpen(!isChatOpen)}
              chatHistory={chatHistory}
              onSendMessage={handleSendMessageToAI}
              suggestions={DEFAULT_SUGGESTIONS}
              selectedChart={selectedChartForAI}
            />
          </div>
        </SidebarInset>
      </div>
      <ModalWindow
        isOpen={isAddPbiModalOpen}
        onClose={() => setIsAddPbiModalOpen(false)}
        onAdd={handleAddDynamicPbiReports}
      />
    </SidebarProvider>
  );
};

export default Dashboard;



================
File: src/utils/dataParsing.ts
================
/**
 * Parses CSV data to extract the word value and formats large numbers.
 *
 * This function first checks if the CSV contains comma-separated values with a header.
 * If not, it assumes a simple two-line format where the first line is a header (e.g., "Returns")
 * and the second line is the word value (e.g., "$52342").
 * If the number is greater than or equal to 1000, it will format it using 'k', 'M', etc.
 *
 * @param csvData - String containing CSV formatted data
 * @returns Formatted word string (e.g. "$523k" or "$1.5M")
 */
export function parseData(csvData: string): string {
  console.log('Parsing CSV data for a word...');
  
  // Trim and split the CSV data into non-empty lines.
  const lines = csvData.split("\n").map(line => line.trim()).filter(line => line !== "");
  
  // Fallback: If we have at least two lines, assume the second line is a word value.
  if (lines.length >= 2) {
    let value = lines[1];
    
    // Check if the value is a valid number (after removing non-numeric characters like '$')
    const numericValue = parseFloat(value.replace(/[^\d.-]/g, ''));
    
    // If it's a valid number, format it
    if (!isNaN(numericValue)) {
      value = formatNumber(numericValue);
    }
    
    console.log('Fallback: assuming second line is a word:', value);
    return value;
  }
  
  console.warn('Word not found in CSV data.');
  return "No data found for this visual."; // More descriptive message
}

/**
 * Formats numbers larger than 1000 with 'k', 'M', etc.
 * 
 * @param num - The numeric value to format.
 * @returns Formatted string (e.g. 1000 => '1k', 1000000 => '1M')
 */
function formatNumber(num: number): string {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1) + 'M'; // Format as millions
  }
  if (num >= 10000) {
    return (num / 1000).toFixed(1) + 'k'; // Format as thousands
  }
  return num.toString(); // No formatting for smaller numbers
}



================
File: src/pages/Index.tsx
================
// src/pages/Index.tsx
import { useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom'; // Import useLocation
import Dashboard from './Dashboard';

const Index = () => {
  const navigate = useNavigate();
  const location = useLocation(); // Hook to access URL details

  // Check if user is logged in, otherwise redirect to login
  useEffect(() => {
    let user = localStorage.getItem('user');
    const params = new URLSearchParams(location.search);
    const idToken = params.get('token'); // Get the token from URL query params

    if (idToken) {
      // If token found in URL, update localStorage
      let parsedUser = {};
      if (user) {
        try {
          parsedUser = JSON.parse(user);
        } catch (e) {
          console.error("Failed to parse existing user data from localStorage:", e);
        }
      }
      
      // Add or update the id_token in the user object
      const updatedUser = { ...parsedUser, id_token: idToken };
      localStorage.setItem('user', JSON.stringify(updatedUser));
      user = JSON.stringify(updatedUser); // Update local 'user' variable for immediate use

      // Clean the URL to remove the token
      // This prevents the token from lingering in the address bar or browser history
      navigate(location.pathname, { replace: true });

      console.log('ID Token found in URL and stored in localStorage.');
    }

    if (!user) {
      console.log('[Index] No user or ID Token found, navigating to /login.');
      navigate('/login');
    } else {
      console.log('[Index] User found. Loading Dashboard.');
    }
  }, [navigate, location.search, location.pathname]); // Depend on search and pathname to re-run if URL changes

  return <Dashboard />;
};

export default Index;

================
File: src/pages/Login.tsx
================
// src/pages/Login.tsx
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { useToast } from '@/hooks/use-toast';
import { Separator } from '@/components/ui/separator';
import { Facebook, Github, Linkedin, Mail } from 'lucide-react';

const Login = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const navigate = useNavigate();
  const { toast } = useToast();

  const handleLogin = (e: React.FormEvent) => {
    e.preventDefault();

    if (email && password) {
      // Simulate loading
      setTimeout(() => {
        // Store some demo user data, INCLUDING a dummy id_token
        localStorage.setItem('user', JSON.stringify({
          email,
          name: email.split('@')[0],
          id_token: 'dummy-jwt-token-for-authentication-simulation', // <--- ADDED DUMMY TOKEN
        }));

        toast({
          title: 'Login successful',
          description: 'Welcome to the PowerBI Dashboard',
        });

        navigate('/');
      }, 1000);
    } else {
      toast({
        title: 'Error',
        description: 'Please enter your email and password',
        variant: 'destructive',
      });
    }
  };

  const handleSocialLogin = (provider: string) => {
    toast({
      title: `${provider} login`,
      description: `Redirecting to ${provider} for authentication...`,
    });

    // Simulate successful login after a delay
    setTimeout(() => {
      localStorage.setItem('user', JSON.stringify({
        email: `user@${provider.toLowerCase()}.com`,
        name: `${provider}User`,
        id_token: `dummy-jwt-token-for-${provider.toLowerCase()}-simulation`, // <--- ADDED DUMMY TOKEN
      }));

      toast({
        title: 'Login successful',
        description: `Welcome back, ${provider}User!`,
      });

      navigate('/');
    }, 1500);
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-indigo-50 via-white to-cyan-100 dark:from-gray-900 dark:via-gray-950 dark:to-gray-800 p-4">
      <Card className="w-full max-w-md shadow-xl">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl font-bold text-center">PowerBI Dashboard</CardTitle>
          <CardDescription className="text-center">
            Enter your credentials to access your dashboard
          </CardDescription>
        </CardHeader>
        <form onSubmit={handleLogin}>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                placeholder="your.email@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
              />
            </div>
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="password">Password</Label>
                <a href="#" className="text-xs text-primary hover:underline">
                  Forgot password?
                </a>
              </div>
              <Input
                id="password"
                type="password"
                placeholder=""
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
            </div>
            <Button type="submit" className="w-full">
              Sign In with Email
            </Button>

            <div className="relative my-4">
              <div className="absolute inset-0 flex items-center">
                <Separator className="w-full" />
              </div>
              <div className="relative flex justify-center text-xs uppercase">
                <span className="bg-card px-2 text-muted-foreground">Or continue with</span>
              </div>
            </div>

            <div className="grid grid-cols-3 gap-3">
              <Button
                variant="outline"
                className="w-full"
                onClick={() => handleSocialLogin('Github')}
              >
                <Github className="mr-2 h-4 w-4" />
                Github
              </Button>
              <Button
                variant="outline"
                className="w-full"
                onClick={() => handleSocialLogin('LinkedIn')}
              >
                <Linkedin className="mr-2 h-4 w-4" />
                LinkedIn
              </Button>
              <Button
                variant="outline"
                className="w-full bg-blue-50 hover:bg-blue-100 dark:bg-blue-950 dark:hover:bg-blue-900"
                onClick={() => handleSocialLogin('Facebook')}
              >
                <Facebook className="mr-2 h-4 w-4" />
                Facebook
              </Button>
            </div>
          </CardContent>
        </form>
        <CardFooter className="flex flex-col">
          <div className="mt-4 text-center text-sm">
            <span>Don't have an account? </span>
            <a href="#" className="text-primary hover:underline">
              Sign up
            </a>
          </div>
        </CardFooter>
      </Card>
    </div>
  );
};

export default Login;



================
File: src/pages/powerBiContainer.tsx
================
// PowerBIContainer.tsx
import React, { useRef, useEffect } from 'react';
import * as pbi from 'powerbi-client';
import { powerBiService, PowerBiEmbedData } from '@/services/powerBiUtils';

interface PowerBIContainerProps {
  embedData: PowerBiEmbedData;
  pageName: string;
  visualName: string;
}

export default function PowerBIContainer({ embedData, pageName, visualName }: PowerBIContainerProps) {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!containerRef.current) return;
    // Clean up any old embed
    powerBiService.reset(containerRef.current);

    const config: pbi.IVisualEmbedConfiguration = {
      type: 'visual',
      accessToken: embedData.token,
      embedUrl: embedData.embedUrl,
      id: embedData.reportId,
      pageName,
      visualName,
      permissions: pbi.models.Permissions.Read,
      tokenType: pbi.models.TokenType.Embed
    };

    const visual = powerBiService.embed(containerRef.current, config);
    return () => {
      powerBiService.reset(containerRef.current!);
    };
  // We pass an empty deps array so React never reruns this effect after mount
  }, []);

  // React will never try to diff _inside_ this div
  return <div ref={containerRef} style={{ width: '100%', height: '100%' }} />;
}

================
File: src/services/powerBiUtils.ts
================
// src/services/powerBiUtils.ts
import * as pbi from 'powerbi-client';

const API_BASE_URL = import.meta.env.VITE_YOUR_BACKEND_API_URL || 'http://localhost:3000';
console.log('[PBIUtils] API_BASE_URL:', API_BASE_URL);


export interface PowerBiEmbedData {
  token: string;
  embedUrl: string;
  reportId: string;
  expiration?: string;
  cacheStatus?: string;
}

export const powerBiService = new pbi.service.Service(
  pbi.factories.hpmFactory,
  pbi.factories.wpmpFactory,
  pbi.factories.routerFactory
);

export const fetchMainEmbedData = async (): Promise<PowerBiEmbedData> => {
  console.log('[PBIUtils] fetchMainEmbedData called');
  try {
    const response = await fetch(`${API_BASE_URL}/getEmbedToken`);
    console.log('[PBIUtils] fetchMainEmbedData response status:', response.status);

    if (!response.ok) {
      let errorData;
      try {
        errorData = await response.json();
        console.error('[PBIUtils] fetchMainEmbedData error response JSON:', errorData);
      } catch (e) {
        const errorText = await response.text();
        console.error('[PBIUtils] fetchMainEmbedData error response text:', errorText);
        errorData = { errorMessage: "Failed to parse error response", errorText };
      }
      throw new Error(`Failed to fetch Power BI embed data: ${response.status} - ${errorData.errorMessage || response.statusText}`);
    }
    const data = await response.json();
    console.log('[PBIUtils] fetchMainEmbedData raw data received:', data);

    if (!data.token || !data.embedUrl || !data.reportId) {
        console.error("[PBIUtils] Incomplete embed data received from backend:", data);
        throw new Error('Incomplete embed data received from backend (missing token, embedUrl, or reportId).');
    }
    
    const embedData: PowerBiEmbedData = {
        token: data.token,
        embedUrl: data.embedUrl,
        reportId: data.reportId,
        expiration: data.expiration,
        cacheStatus: data.cacheStatus
    };
    console.log('[PBIUtils] fetchMainEmbedData processed embedData:', embedData);
    return embedData;

  } catch (error)
{
    console.error("[PBIUtils] Error in fetchMainEmbedData:", error);
    throw error;
  }
};

================
File: src/types/chart.ts
================
// src/types/chart.ts
import { Layout } from 'react-grid-layout';
import React from 'react';

// Define PowerBiConfig if it's not already defined elsewhere and imported
export interface PowerBiConfig {
  pageName: string;
  visualName: string;
  // reportId?: string; // Not strictly needed here if mainEmbedData provides it
  // embedUrl?: string; // Not strictly needed here if mainEmbedData provides it
}

export interface AISuggestion {
  question: string;
}

export type ChartType = {
  id: string;
  name: string;
  type: 'bar' | 'line' | 'pie' | 'area' | 'radar' | 'scatter' | 'iframe' | 'powerbi'; // <-- ADDED 'powerbi'
  content: string; // For PBI, this is a description. For iframe, it's URL. For others, SVG/data.
  icon: React.ReactNode;
  layout: Layout;
  powerBiConfig?: PowerBiConfig; // <-- ADDED for Power BI visuals
  askableQuestions: string[];
  suggestions?: AISuggestion[]; // For backward compatibility
  isDynamicPBI?: boolean;      // <-- ADDED for dynamically added PBI visuals
};

================
File: src/types/chat.ts
================
// src/types/chat.ts
export interface ChatMessage {
  message: string;
  isUser: boolean;
  imageBase64?: string;
  chartContent?: string;
  isLoading?: boolean; // ADDED: To indicate if the AI response is still loading
}

export interface ChatSuggestion {
  question: string;
}

// Define Speech Recognition interface
interface SpeechRecognitionEvent extends Event {
  results: SpeechRecognitionResultList;
  resultIndex: number;
  interpretation: string;
  emma: string;
}

interface SpeechRecognitionResult {
  transcript: string;
  confidence: number;
  isFinal?: boolean;
}

interface SpeechRecognitionResultList {
  length: number;
  item(index: number): SpeechRecognitionResult;
  [index: number]: SpeechRecognitionResult;
}

interface SpeechRecognitionError extends Event {
  error: string;
  message: string;
}

export interface SpeechRecognition extends EventTarget {
  continuous: boolean;
  interimResults: boolean;
  lang: string;
  maxAlternatives: number;
  start(): void;
  stop(): void;
  abort(): void;
  onaudiostart: ((this: SpeechRecognition, ev: Event) => any) | null;
  onaudioend: ((this: SpeechRecognition, ev: Event) => any) | null;
  onend: ((this: SpeechRecognition, ev: Event) => any) | null;
  onerror: ((this: SpeechRecognition, ev: SpeechRecognitionError) => any) | null;
  onnomatch: ((this: SpeechRecognition, ev: Event) => any) | null;
  onresult: ((this: SpeechRecognition, ev: SpeechRecognitionEvent) => any) | null;
  onstart: ((this: SpeechRecognition, ev: Event) => any) | null;
  onsoundstart: ((this: SpeechRecognition, ev: Event) => any) | null;
  onsoundend: ((this: SpeechRecognition, ev: Event) => any) | null;
  onspeechstart: ((this: SpeechRecognition, ev: Event) => any) | null;
  onspeechend: ((this: SpeechRecognition, ev: Event) => any) | null;
}



================
File: src/types/page.ts
================


export interface DashboardPage {
  id: string;
  name: string;
  charts: string[]; // Array of chart IDs
  layout?: { [key: string]: any }; // Store layout configuration per page
  isDefault?: boolean;
}

export interface PageContextType {
  pages: DashboardPage[];
  currentPageId: string;
  setCurrentPageId: (pageId: string) => void;
  addPage: (name: string) => void;
  deletePage: (pageId: string) => void;
  updatePageCharts: (pageId: string, chartIds: string[]) => void;
  updatePageLayout: (pageId: string, layout: any) => void;
}



================
File: src/App.css
================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

================
File: src/App.tsx
================
import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { ThemeProvider } from "@/hooks/use-theme";
import Index from "./pages/Index";
import Login from "./pages/Login";
import NotFound from "./pages/NotFound";

const queryClient = new QueryClient();

const App = () => (
  <QueryClientProvider client={queryClient}>
    <ThemeProvider defaultTheme="system">
      <TooltipProvider>
        <Toaster />
        <Sonner />
        <BrowserRouter>
          <Routes>
            <Route path="/" element={<Index />} />
            <Route path="/login" element={<Login />} />
            <Route path="*" element={<NotFound />} />
          </Routes>
        </BrowserRouter>
      </TooltipProvider>
    </ThemeProvider>
  </QueryClientProvider>
);

export default App;

================
File: src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;

    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;

    --primary: 271 81% 56%;
    --primary-foreground: 210 40% 98%;

    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;

    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;

    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;

    --radius: 0.75rem;

    --sidebar-background: 271 81% 56%;
    --sidebar-foreground: 210 40% 98%;
    --sidebar-primary: 210 40% 98%;
    --sidebar-primary-foreground: 271 81% 56%;
    --sidebar-accent: 271 76% 60%;
    --sidebar-accent-foreground: 210 40% 98%;
    --sidebar-border: 271 76% 60%;
    --sidebar-ring: 217.2 91.2% 59.8%;

    /* Chart labels and accent colors */
    --chart-label-primary: 0 0% 15%;
    --chart-accent-1: 271 81% 56%; /* Purple */
    --chart-accent-2: 329 86% 56%; /* Pink */
    --chart-accent-3: 21 90% 48%;  /* Orange */
    --chart-accent-4: 217 91% 60%; /* Blue */
    --chart-accent-5: 142 71% 45%; /* Green */
    --chart-accent-6: 0 84% 60%;   /* Red */
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;

    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;

    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;

    --primary: 271 81% 56%;
    --primary-foreground: 210 40% 98%;

    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;

    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;

    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;

    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --sidebar-background: 271 81% 56%;
    --sidebar-foreground: 210 40% 98%;
    --sidebar-primary: 210 40% 98%;
    --sidebar-primary-foreground: 271 81% 56%;
    --sidebar-accent: 271 76% 60%;
    --sidebar-accent-foreground: 210 40% 98%;
    --sidebar-border: 271 76% 60%;
    --sidebar-ring: 217.2 91.2% 59.8%;

    /* Chart labels and accent colors in dark mode */
    --chart-label-primary: 0 0% 95%;
    --chart-accent-1: 271 81% 65%; /* Purple */
    --chart-accent-2: 329 86% 65%; /* Pink */
    --chart-accent-3: 21 90% 60%;  /* Orange */
    --chart-accent-4: 217 91% 70%; /* Blue */
    --chart-accent-5: 142 71% 55%; /* Green */
    --chart-accent-6: 0 84% 70%;   /* Red */
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-gray-50 text-foreground;
  }
}

@layer components {
  .gradient-card {
    background: linear-gradient(135deg, #f59e0b 0%, #ea580c 100%);
    box-shadow: 0 10px 15px -3px rgb(245 158 11 / 0.15), 0 4px 6px -4px rgb(245 158 11 / 0.15);
  }
  
  .purple-gradient {
    background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%);
    box-shadow: 0 10px 15px -3px rgb(124 58 237 / 0.15), 0 4px 6px -4px rgb(124 58 237 / 0.15);
  }
  
  .blue-gradient {
    background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
    box-shadow: 0 10px 15px -3px rgb(6 182 212 / 0.15), 0 4px 6px -4px rgb(6 182 212 / 0.15);
  }
  
  .pink-gradient {
    background: linear-gradient(135deg, #ec4899 0%, #be185d 100%);
    box-shadow: 0 10px 15px -3px rgb(236 72 153 / 0.15), 0 4px 6px -4px rgb(236 72 153 / 0.15);
  }

  /* Enhanced chart styling */
  .enhanced-chart text {
    font-weight: 500 !important;
    font-size: 12px !important;
    fill: hsl(var(--chart-label-primary)) !important;
  }
  
  .enhanced-chart .recharts-cartesian-axis-tick-value {
    font-weight: 600 !important;
  }
  
  .enhanced-chart .recharts-legend-item-text {
    font-weight: 600 !important;
    color: hsl(var(--chart-label-primary)) !important;
  }
  
  .enhanced-chart .recharts-tooltip-wrapper {
    border-radius: var(--radius) !important;
    box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1) !important;
  }
}

================
File: src/main.tsx
================
import { createRoot } from 'react-dom/client'
import App from './App.tsx'
import './index.css'

createRoot(document.getElementById("root")!).render(<App />);



================
File: index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>data-scribe-ai-dashboard</title>
    <meta name="description" content="Lovable Generated Project" />
    <meta name="author" content="Lovable" />

    <meta property="og:title" content="data-scribe-ai-dashboard" />
    <meta property="og:description" content="Lovable Generated Project" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@lovable_dev" />
    <meta name="twitter:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />
  </head>

  <body>
    <div id="root"></div>
    <!-- IMPORTANT: DO NOT REMOVE THIS SCRIPT TAG OR THIS VERY COMMENT! -->
    <script src="https://cdn.gpteng.co/gptengineer.js" type="module"></script>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "vite_react_shadcn_ts",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.0",
    "@radix-ui/react-accordion": "^1.2.0",
    "@radix-ui/react-alert-dialog": "^1.1.1",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.0",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-collapsible": "^1.1.0",
    "@radix-ui/react-context-menu": "^2.2.1",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-hover-card": "^1.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.1",
    "@radix-ui/react-navigation-menu": "^1.2.0",
    "@radix-ui/react-popover": "^1.1.1",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.0",
    "@radix-ui/react-scroll-area": "^1.1.0",
    "@radix-ui/react-select": "^2.1.1",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.1",
    "@radix-ui/react-toggle": "^1.1.0",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@tanstack/react-query": "^5.56.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "date-fns": "^3.6.0",
    "embla-carousel-react": "^8.3.0",
    "html2canvas": "^1.4.1",
    "input-otp": "^1.2.4",
    "jwt-decode": "^4.0.0",
    "lucide-react": "^0.462.0",
    "next-themes": "^0.3.0",
    "powerbi-client": "^2.23.1",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-grid-layout": "^1.5.1",
    "react-hook-form": "^7.53.0",
    "react-resizable-panels": "^2.1.3",
    "react-router-dom": "^6.26.2",
    "recharts": "^2.12.7",
    "sonner": "^1.5.0",
    "svg-to-img": "^2.0.9",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.3",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.0",
    "@tailwindcss/typography": "^0.5.15",
    "@types/node": "^22.5.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react-swc": "^3.5.0",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.9.0",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.9",
    "globals": "^15.9.0",
    "lovable-tagger": "^1.1.7",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.11",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.0.1",
    "vite": "^5.4.1"
  }
}


================================================================
End of Codebase
================================================================